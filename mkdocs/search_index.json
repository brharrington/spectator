{
    "docs": [
        {
            "location": "/", 
            "text": "Simple library for instrumenting code to record dimensional time series. If\nyou are new to the library it is highly recommended to read the pages in the\n\nGetting Started\n section on the sidebar.\n\n\nAt a minimum you will need to:\n\n\n\n\nDepend on the api library. It is in maven central, for gradle the dependency\n   would be \ncom.netflix.spectator:spectator-api:0.35.0\n.\n\n\nInstrument some code, see the usage guides for \ncounters\n,\n   \ntimers\n, and \ngauges\n.\n\n\nPick a registry to bind to when initializing the application. See the sidebar\n   for a list of available registries.", 
            "title": "Home"
        }, 
        {
            "location": "/intro/counter/", 
            "text": "Counters\n\n\nA counter is used to measure the rate at which some event is occurring.\nConsider a simple queue, counters would be used to measure things like the\nrate at which items are being inserted and removed. \n\n\nCounters are created using the registry which will be setup as part of\napplication initialization. For example:\n\n\npublic class Queue {\n\n  private final Counter insertCounter;\n  private final Counter removeCounter;\n  private final QueueImpl impl;\n\n  @Inject\n  public Queue(Registry registry) {\n    insertCounter = registry.counter(\nqueue.insert\n);\n    removeCounter = registry.counter(\nqueue.remove\n);\n    impl = new QueueImpl();\n  }\n\n\n\n\nThen call increment when an event occurs:\n\n\n  public void insert(Object obj) {\n    insertCounter.increment();\n    impl.insert(obj);\n  }\n\n  public Object remove() {\n    if (impl.nonEmpty()) {\n      removeCounter.increment();\n      return impl.remove();\n    } else {\n      return null;\n    }\n  }\n\n\n\n\nOptionally an amount can be passed in when calling increment. This is useful\nwhen a collection of events happens together. \n\n\n  public void insertAll(Collection\nObject\n objs) {\n    insertCounter.increment(objs.size());\n    impl.insertAll(objs);\n  }\n}", 
            "title": "Counters"
        }, 
        {
            "location": "/intro/counter/#counters", 
            "text": "A counter is used to measure the rate at which some event is occurring.\nConsider a simple queue, counters would be used to measure things like the\nrate at which items are being inserted and removed.   Counters are created using the registry which will be setup as part of\napplication initialization. For example:  public class Queue {\n\n  private final Counter insertCounter;\n  private final Counter removeCounter;\n  private final QueueImpl impl;\n\n  @Inject\n  public Queue(Registry registry) {\n    insertCounter = registry.counter( queue.insert );\n    removeCounter = registry.counter( queue.remove );\n    impl = new QueueImpl();\n  }  Then call increment when an event occurs:    public void insert(Object obj) {\n    insertCounter.increment();\n    impl.insert(obj);\n  }\n\n  public Object remove() {\n    if (impl.nonEmpty()) {\n      removeCounter.increment();\n      return impl.remove();\n    } else {\n      return null;\n    }\n  }  Optionally an amount can be passed in when calling increment. This is useful\nwhen a collection of events happens together.     public void insertAll(Collection Object  objs) {\n    insertCounter.increment(objs.size());\n    impl.insertAll(objs);\n  }\n}", 
            "title": "Counters"
        }, 
        {
            "location": "/intro/timer/", 
            "text": "Timers\n\n\nA timer is used to measure how long some event is taking. Two types of timers\nare supported:\n\n\n\n\nTimer\n: for frequent short duration events.\n\n\nLongTaskTimer\n: for long running tasks.\n\n\n\n\nThe long duration timer is setup so that you can track the time while an\nevent being measured is still running. A regular timer just records the\nduration and has no information until the task is complete.\n\n\nAs an example, consider a chart showing request latency to a typical web\nserver. The expectation is many short requests so the timer will be getting\nupdated many times per second.\n\n\n\n\nNow consider a background process to refresh metadata from a data store. For\nexample, Edda caches AWS resources such as instances, volumes, auto-scaling\ngroups etc. Normally all data can be refreshed in a few minutes. If the AWS\nservices are having problems it can take much longer. A long duration timer\ncan be used to track the overall time for refreshing the metadata.\n\n\nThe charts below show max latency for the refresh using a regular timer and\na long task timer. Regular timer, note that the y-axis is using a logarithmic\nscale:\n\n\n\n\nLong task timer:\n\n\n\n\nTimer\n\n\nTo get started create an instance using the registry:\n\n\npublic class Server {\n\n  private final Registry registry;\n  private final Timer requestLatency;\n\n  @Inject\n  public Server(Registry registry) {\n    this.registry = registry;\n    requestLatency = registry.timer(\nserver.requestLatency\n);\n  }\n\n\n\n\nThen wrap the call you need to measure:\n\n\n  public Response handle(Request request) {\n    final long start = registry.clock().elapsedTime();\n    try {\n      return handleImpl(request);\n    } finally {\n      final long end = registry.clock().elapsedTime();\n      requestLatency.record(end - start, TimeUnit.NANOSECONDS);\n    }\n  }\n\n\n\n\nThis example uses the clock from the registry which can be useful for\ntesting if you need to control the timing. In actual usage it will typically\nget mapped to the system clock. It is recommended to use a monotonically\nincreasing source for measuring the times to avoid occasionally having bogus\nmeasurements due to time adjustments. For more information see the\n\nClock documentation\n.\n\n\nAlso note that the record call is done in a finally block to ensure that\nthe time will get recorded if a failure occurs. The example above could have\nalso been done using a lambda:\n\n\n  public Response handle(Request request) {\n    return requestLatency.record(() -\n handleImpl(request));\n  }\n\n\n\n\nLongTaskTimer\n\n\nTo get started create an instance using the registry:\n\n\npublic class MetadataService {\n\n  private final LongTaskTimer metadataRefresh;\n\n  @Inject\n  public MetadataService(Registry registry) {\n    metadataRefresh = registry.longTaskTimer(\nmetadata.refreshDuration\n);\n    // setup background thread to call refresh()\n  }\n\n  private void refresh() {\n    final int id = metadataRefresh.start();\n    try {\n      refreshImpl();\n    } finally {\n      metadataRefresh.stop(id);\n    }\n  }\n\n\n\n\nThe id is used to keep track of a particular task being measured by the timer.\nIt must be stopped using the provided id. Note that unlike a regular timer\nthat does not do anything until the final duration is recorded, a long duration\ntimer will report as two gauges:\n\n\n\n\nduration\n: total duration spent within all currently running tasks.\n\n\nactiveTasks\n: number of currently running tasks.\n\n\n\n\nThis means that you can see what is happening while the task is running, but\nyou need to keep in mind:\n\n\n\n\nThe id is fixed before the task begins. There is no way to change tags based\n  on the run, e.g., update a different timer if an exception is thrown.\n\n\nBeing a guage it is inappropriate for short tasks. In particular, gauges are\n  sampled and if it is not sampled during the execution or the sampling period\n  is a significant subset of the expected duration, then the duration value\n  will not be meaningful.\n\n\n\n\nLike a regular timer, the duration timer also supports using a lambda to\nsimplify the common case:\n\n\n  private void refresh() {\n    metadataRefresh.record(this::refreshImpl);\n  }", 
            "title": "Timers"
        }, 
        {
            "location": "/intro/timer/#timers", 
            "text": "A timer is used to measure how long some event is taking. Two types of timers\nare supported:   Timer : for frequent short duration events.  LongTaskTimer : for long running tasks.   The long duration timer is setup so that you can track the time while an\nevent being measured is still running. A regular timer just records the\nduration and has no information until the task is complete.  As an example, consider a chart showing request latency to a typical web\nserver. The expectation is many short requests so the timer will be getting\nupdated many times per second.   Now consider a background process to refresh metadata from a data store. For\nexample, Edda caches AWS resources such as instances, volumes, auto-scaling\ngroups etc. Normally all data can be refreshed in a few minutes. If the AWS\nservices are having problems it can take much longer. A long duration timer\ncan be used to track the overall time for refreshing the metadata.  The charts below show max latency for the refresh using a regular timer and\na long task timer. Regular timer, note that the y-axis is using a logarithmic\nscale:   Long task timer:", 
            "title": "Timers"
        }, 
        {
            "location": "/intro/timer/#timer", 
            "text": "To get started create an instance using the registry:  public class Server {\n\n  private final Registry registry;\n  private final Timer requestLatency;\n\n  @Inject\n  public Server(Registry registry) {\n    this.registry = registry;\n    requestLatency = registry.timer( server.requestLatency );\n  }  Then wrap the call you need to measure:    public Response handle(Request request) {\n    final long start = registry.clock().elapsedTime();\n    try {\n      return handleImpl(request);\n    } finally {\n      final long end = registry.clock().elapsedTime();\n      requestLatency.record(end - start, TimeUnit.NANOSECONDS);\n    }\n  }  This example uses the clock from the registry which can be useful for\ntesting if you need to control the timing. In actual usage it will typically\nget mapped to the system clock. It is recommended to use a monotonically\nincreasing source for measuring the times to avoid occasionally having bogus\nmeasurements due to time adjustments. For more information see the Clock documentation .  Also note that the record call is done in a finally block to ensure that\nthe time will get recorded if a failure occurs. The example above could have\nalso been done using a lambda:    public Response handle(Request request) {\n    return requestLatency.record(() -  handleImpl(request));\n  }", 
            "title": "Timer"
        }, 
        {
            "location": "/intro/timer/#longtasktimer", 
            "text": "To get started create an instance using the registry:  public class MetadataService {\n\n  private final LongTaskTimer metadataRefresh;\n\n  @Inject\n  public MetadataService(Registry registry) {\n    metadataRefresh = registry.longTaskTimer( metadata.refreshDuration );\n    // setup background thread to call refresh()\n  }\n\n  private void refresh() {\n    final int id = metadataRefresh.start();\n    try {\n      refreshImpl();\n    } finally {\n      metadataRefresh.stop(id);\n    }\n  }  The id is used to keep track of a particular task being measured by the timer.\nIt must be stopped using the provided id. Note that unlike a regular timer\nthat does not do anything until the final duration is recorded, a long duration\ntimer will report as two gauges:   duration : total duration spent within all currently running tasks.  activeTasks : number of currently running tasks.   This means that you can see what is happening while the task is running, but\nyou need to keep in mind:   The id is fixed before the task begins. There is no way to change tags based\n  on the run, e.g., update a different timer if an exception is thrown.  Being a guage it is inappropriate for short tasks. In particular, gauges are\n  sampled and if it is not sampled during the execution or the sampling period\n  is a significant subset of the expected duration, then the duration value\n  will not be meaningful.   Like a regular timer, the duration timer also supports using a lambda to\nsimplify the common case:    private void refresh() {\n    metadataRefresh.record(this::refreshImpl);\n  }", 
            "title": "LongTaskTimer"
        }, 
        {
            "location": "/intro/gauge/", 
            "text": "Gauges\n\n\nA gauge is a handle to get the current value. Typical examples for gauges\nwould be the size of a queue or number of threads in the running state.\nSince gauges are sampled, there is no information about what might have\noccurred between samples.\n\n\nConsider monitoring the behavior of a queue of tasks. If the data is being\ncollected once a minute, then a gauge for the size will show the size when\nit was sampled. The size may have been much higher or lower at some point\nduring interval, but that is not known.\n\n\nRegistration\n\n\nA gauge is registered by passing in an id, a reference to the object, and\na function to get or compute a numeric value based on the object. The\nreference to the object is passed in separately and the spectator registry\nwill keep a weak reference to the object. If the object is garbage collected,\nthen it will automatically drop the registration.\n\n\nWhen multiple gauges are registered with the same id the reported value will\nbe the sum of the matches.\n\n\nUsing Lambda\n\n\nSpecify a lambda that takes the object as parameter.\n\n\npublic class Queue {\n\n  @Inject\n  public Queue(Registry registry) {\n    registry.gauge(\nqueue.size\n, this, Queue::size);\n  }\n\n  ...\n}\n\n\n\n\n\n\nWarning\n\n\nBe careful to avoid creating a reference to the object in the\nlambda. It will prevent garbage collection and can lead to a memory leak\nin the application. For example, by calling size without using the passed\nin object there will be a reference to \nthis\n:\n\n\nregistry.gauge(\"queue.size\", this, obj -\n size());\n\n\n\n\nUsing Reflection\n\n\nUse reflection to call a method on an object. The method must have an empty\nparameter list and return a number. This approach can be used to access\nmethods that are not public.\n\n\npublic class Queue {\n\n  @Inject\n  public Queue(Registry registry) {\n    registry.methodValue(\nqueue.size\n, this, \nsize\n);\n  }\n\n  ...\n}\n\n\n\n\nUsing Number\n\n\nA gauge can also be created based on an implementation of Number. For example:\n\n\nAtomicInteger size = new AtomicInteger();\nregistry.gauge(\nqueue.size\n, size);\n\n\n\n\nThe call will return the Number so the registration can be inline on the\nassignment:\n\n\nAtomicInteger size = registry.gauge(\nqueue.size\n, new AtomicInteger());\n\n\n\n\nCollection Sizes\n\n\nFor classes that implement \nCollection\n or \nMap\n there are helpers:\n\n\nQueue queue = new LinkedBlockingQueue();\nregistry.collectionSize(\nqueue.size\n, queue);\n\nMap\nString, String\n cache = new ConcurrentMap\n();\nregistry.mapSize(\ncache.size\n, cache);", 
            "title": "Gauges"
        }, 
        {
            "location": "/intro/gauge/#gauges", 
            "text": "A gauge is a handle to get the current value. Typical examples for gauges\nwould be the size of a queue or number of threads in the running state.\nSince gauges are sampled, there is no information about what might have\noccurred between samples.  Consider monitoring the behavior of a queue of tasks. If the data is being\ncollected once a minute, then a gauge for the size will show the size when\nit was sampled. The size may have been much higher or lower at some point\nduring interval, but that is not known.", 
            "title": "Gauges"
        }, 
        {
            "location": "/intro/gauge/#registration", 
            "text": "A gauge is registered by passing in an id, a reference to the object, and\na function to get or compute a numeric value based on the object. The\nreference to the object is passed in separately and the spectator registry\nwill keep a weak reference to the object. If the object is garbage collected,\nthen it will automatically drop the registration.  When multiple gauges are registered with the same id the reported value will\nbe the sum of the matches.", 
            "title": "Registration"
        }, 
        {
            "location": "/intro/gauge/#using-lambda", 
            "text": "Specify a lambda that takes the object as parameter.  public class Queue {\n\n  @Inject\n  public Queue(Registry registry) {\n    registry.gauge( queue.size , this, Queue::size);\n  }\n\n  ...\n}   Warning  Be careful to avoid creating a reference to the object in the\nlambda. It will prevent garbage collection and can lead to a memory leak\nin the application. For example, by calling size without using the passed\nin object there will be a reference to  this :  registry.gauge(\"queue.size\", this, obj -  size());", 
            "title": "Using Lambda"
        }, 
        {
            "location": "/intro/gauge/#using-reflection", 
            "text": "Use reflection to call a method on an object. The method must have an empty\nparameter list and return a number. This approach can be used to access\nmethods that are not public.  public class Queue {\n\n  @Inject\n  public Queue(Registry registry) {\n    registry.methodValue( queue.size , this,  size );\n  }\n\n  ...\n}", 
            "title": "Using Reflection"
        }, 
        {
            "location": "/intro/gauge/#using-number", 
            "text": "A gauge can also be created based on an implementation of Number. For example:  AtomicInteger size = new AtomicInteger();\nregistry.gauge( queue.size , size);  The call will return the Number so the registration can be inline on the\nassignment:  AtomicInteger size = registry.gauge( queue.size , new AtomicInteger());", 
            "title": "Using Number"
        }, 
        {
            "location": "/intro/gauge/#collection-sizes", 
            "text": "For classes that implement  Collection  or  Map  there are helpers:  Queue queue = new LinkedBlockingQueue();\nregistry.collectionSize( queue.size , queue);\n\nMap String, String  cache = new ConcurrentMap ();\nregistry.mapSize( cache.size , cache);", 
            "title": "Collection Sizes"
        }, 
        {
            "location": "/intro/dist-summary/", 
            "text": "Distribution Summaries\n\n\nA distribution summary is used to track the distribution of events. It is\nsimilar to a timer, but more general in that the size does not have to be\na period of time. For example, a distribution summary could be used to measure\nthe payload sizes of requests hitting a server.\n\n\nIt is recommended to always use base units when recording the data. So if\nmeasuring the payload size use bytes, not kilobytes or some other unit.\n\n\nDistribution summaries are created using the registry which will be setup as\npart of application initialization. For example:\n\n\npublic class Server {\n\n  private final DistributionSummary requestSize;\n\n  @Inject\n  public Server(Registry registry) {\n    requestSize = registry.distributionSummary(\nserver.requestSize\n);\n  }\n\n\n\n\nThen call record when an event occurs:\n\n\n  public Response handle(Request request) {\n    requestSize.record(request.sizeInBytes());\n  }\n}", 
            "title": "Distribution Summaries"
        }, 
        {
            "location": "/intro/dist-summary/#distribution-summaries", 
            "text": "A distribution summary is used to track the distribution of events. It is\nsimilar to a timer, but more general in that the size does not have to be\na period of time. For example, a distribution summary could be used to measure\nthe payload sizes of requests hitting a server.  It is recommended to always use base units when recording the data. So if\nmeasuring the payload size use bytes, not kilobytes or some other unit.  Distribution summaries are created using the registry which will be setup as\npart of application initialization. For example:  public class Server {\n\n  private final DistributionSummary requestSize;\n\n  @Inject\n  public Server(Registry registry) {\n    requestSize = registry.distributionSummary( server.requestSize );\n  }  Then call record when an event occurs:    public Response handle(Request request) {\n    requestSize.record(request.sizeInBytes());\n  }\n}", 
            "title": "Distribution Summaries"
        }, 
        {
            "location": "/intro/testing/", 
            "text": "Testing\n\n\nTesting should be relatively straightforward if you are using injection for the registry. Consider a sample class:\n\n\npublic class Foo {\n\n  private final Counter counter;\n\n  @Inject\n  public Foo(Registry registry) {\n    counter = registry.counter(\nfoo\n);\n  }\n\n  public void doSomething() {\n    counter.increment();\n  }\n}\n\n\n\n\nSimple Test\n\n\nA basic standalone test class would look something like:\n\n\npublic class FooTest {\n\n  private Registry registry;\n  private Foo foo;\n\n  @Before\n  public void init() {\n    registry = new DefaultRegistry();\n    foo = new Foo(registry);\n  }\n\n  @Test\n  public void doSomething() {\n    foo.doSomething();\n    Assert.assertEquals(1, registry.counter(\nfoo\n).count());\n  }\n}\n\n\n\n\nGuice Test\n\n\nIf using guice, then the \nTestModule\n can be used:\n\n\npublic class FooTest {\n\n  private Registry registry;\n  private Foo foo;\n\n  @Before\n  public void init() {\n    Injector injector = Guice.createInjector(new TestModule());\n    registry = injector.getInstance(Registry.class);\n    foo = injector.getInstance(Foo.class);\n  }\n\n  @Test\n  public void doSomething() {\n    foo.doSomething();\n    Assert.assertEquals(1, registry.counter(\nfoo\n).count());\n  }\n}", 
            "title": "Testing"
        }, 
        {
            "location": "/intro/testing/#testing", 
            "text": "Testing should be relatively straightforward if you are using injection for the registry. Consider a sample class:  public class Foo {\n\n  private final Counter counter;\n\n  @Inject\n  public Foo(Registry registry) {\n    counter = registry.counter( foo );\n  }\n\n  public void doSomething() {\n    counter.increment();\n  }\n}", 
            "title": "Testing"
        }, 
        {
            "location": "/intro/testing/#simple-test", 
            "text": "A basic standalone test class would look something like:  public class FooTest {\n\n  private Registry registry;\n  private Foo foo;\n\n  @Before\n  public void init() {\n    registry = new DefaultRegistry();\n    foo = new Foo(registry);\n  }\n\n  @Test\n  public void doSomething() {\n    foo.doSomething();\n    Assert.assertEquals(1, registry.counter( foo ).count());\n  }\n}", 
            "title": "Simple Test"
        }, 
        {
            "location": "/intro/testing/#guice-test", 
            "text": "If using guice, then the  TestModule  can be used:  public class FooTest {\n\n  private Registry registry;\n  private Foo foo;\n\n  @Before\n  public void init() {\n    Injector injector = Guice.createInjector(new TestModule());\n    registry = injector.getInstance(Registry.class);\n    foo = injector.getInstance(Foo.class);\n  }\n\n  @Test\n  public void doSomething() {\n    foo.doSomething();\n    Assert.assertEquals(1, registry.counter( foo ).count());\n  }\n}", 
            "title": "Guice Test"
        }, 
        {
            "location": "/intro/netflix/", 
            "text": "Netflix Integration\n\n\nWhen running at Netflix, use the \natlas-client\n library to enable transferring the instrumented data to \nAtlas\n. See the appropriate section for the type of project you are working on:\n\n\n\n\nLibraries\n\n\nApplications\n, specifically standalone apps using guice or governator directly.\n\n\nBase Server\n\n\n\n\nLibraries\n\n\nFor libraries, the only dependency that should be needed is:\n\n\ncom.netflix.spectator:spectator-api:0.35.0\n\n\n\n\nThe bindings to integrate internally should be included with the application. In your code, just inject a registry, e.g.:\n\n\npublic class Foo {\n  @Inject\n  public Foo(Registry registry) {\n    ...\n  }\n  ...\n}\n\n\n\n\nSee the \ntesting docs\n for more information about creating a binding to use with tests.\n\n\nApplications\n\n\nApplication should include a dependency on the \natlas-client\n plugin:\n\n\nnetflix:atlas-client:latest.release\n\n\n\n\nNote this is an internal only library with configs specific to the Netflix environments. It is assumed you are using Nebula so that internal maven repositories are available for your build. When configuring with governator specify the \nAtlasModule\n:\n\n\nInjector injector = LifecycleInjector.builder()\n    .withModules(new AtlasModule())\n    .build()\n    .createInjector();\n\n\n\n\nThe registry binding will then be available so it can be injected as shown in the \nlibraries section\n. The insight libraries do not use any governator or guice specific features. So it is possible to use guice or other dependency injection frameworks directly with the following caveats:\n\n\n\n\nHowever, some of the libraries do use the \n@PostConstruct\n and \n@PreDestroy\n annotations for managing lifecycle. Governator adds lifecycle management and many other features on top of guice and is the recommended way. For more minimalist support of just the lifecycle annotations on top of guice see \niep-guice\n.\n\n\nThe bindings and configuration necessary to run correctly with the internal setup are only supported as guice modules. If trying to use some other dependency injection framework, then you will be responsible for either finding a way to leverage the guice module in that framework or recreating those bindings and maintaining them as things change. It is not a paved road path.\n\n\n\n\nBase Server\n\n\nIf using \nbase-server\n, then you will get the Spectator and Atlas bindings automatically.\n\n\nAuto Plugin\n\n\n\n\nWarning\n\n\nDeprecated\n: Use of AutoBindSingleton is generally discouraged. It is recommended to\nuse one of the other methods.\n\n\n\n\nIf you are only interested in getting the GC logging, there is a library with an auto-bind singleton that can be used:\n\n\ncom.netflix.spectator:spectator-nflx:0.35.0\n\n\n\n\nAssuming you are using karyon/base-server or governator with \ncom.netflix\n in the list of base packages then the plugin should get automatically loaded.", 
            "title": "Netflix Integration"
        }, 
        {
            "location": "/intro/netflix/#netflix-integration", 
            "text": "When running at Netflix, use the  atlas-client  library to enable transferring the instrumented data to  Atlas . See the appropriate section for the type of project you are working on:   Libraries  Applications , specifically standalone apps using guice or governator directly.  Base Server", 
            "title": "Netflix Integration"
        }, 
        {
            "location": "/intro/netflix/#libraries", 
            "text": "For libraries, the only dependency that should be needed is:  com.netflix.spectator:spectator-api:0.35.0  The bindings to integrate internally should be included with the application. In your code, just inject a registry, e.g.:  public class Foo {\n  @Inject\n  public Foo(Registry registry) {\n    ...\n  }\n  ...\n}  See the  testing docs  for more information about creating a binding to use with tests.", 
            "title": "Libraries"
        }, 
        {
            "location": "/intro/netflix/#applications", 
            "text": "Application should include a dependency on the  atlas-client  plugin:  netflix:atlas-client:latest.release  Note this is an internal only library with configs specific to the Netflix environments. It is assumed you are using Nebula so that internal maven repositories are available for your build. When configuring with governator specify the  AtlasModule :  Injector injector = LifecycleInjector.builder()\n    .withModules(new AtlasModule())\n    .build()\n    .createInjector();  The registry binding will then be available so it can be injected as shown in the  libraries section . The insight libraries do not use any governator or guice specific features. So it is possible to use guice or other dependency injection frameworks directly with the following caveats:   However, some of the libraries do use the  @PostConstruct  and  @PreDestroy  annotations for managing lifecycle. Governator adds lifecycle management and many other features on top of guice and is the recommended way. For more minimalist support of just the lifecycle annotations on top of guice see  iep-guice .  The bindings and configuration necessary to run correctly with the internal setup are only supported as guice modules. If trying to use some other dependency injection framework, then you will be responsible for either finding a way to leverage the guice module in that framework or recreating those bindings and maintaining them as things change. It is not a paved road path.", 
            "title": "Applications"
        }, 
        {
            "location": "/intro/netflix/#base-server", 
            "text": "If using  base-server , then you will get the Spectator and Atlas bindings automatically.", 
            "title": "Base Server"
        }, 
        {
            "location": "/intro/netflix/#auto-plugin", 
            "text": "Warning  Deprecated : Use of AutoBindSingleton is generally discouraged. It is recommended to\nuse one of the other methods.   If you are only interested in getting the GC logging, there is a library with an auto-bind singleton that can be used:  com.netflix.spectator:spectator-nflx:0.35.0  Assuming you are using karyon/base-server or governator with  com.netflix  in the list of base packages then the plugin should get automatically loaded.", 
            "title": "Auto Plugin"
        }, 
        {
            "location": "/intro/servo-comparison/", 
            "text": "Servo Comparison\n\n\nServo\n is an alternative client monitoring\nlibrary that is also developed by Netflix. Originally spectator was an\nexperiment for a simpler API that wrapped servo. It was done as a separate\nproject to avoid breaking backwards compatibility for servo.\n\n\nFrom a user perspective, both will be supported for a long time, but most\nof our efforts for future improvement will go to spectator. For new code it\nis recommended to use the spectator API. If running\n\nat Netflix\n the correct bindings will be in place\nfor both servo and spectator.\n\n\nDifferences\n\n\nThis section provides a quick summary of the differences.\n\n\nSimpler API\n\n\nServo gives the user a lot of control, but this makes it hard to use\ncorrectly. For example, to create a counter the user needs to understand\nthe tradeoffs and choose between:\n\n\n\n\nBasicCounter\n\n\nDynamicCounter\n\n\nContextualCounter\n\n\nStepCounter\n\n\n\n\nFurther each of these can impact how data is reported to observers. The\nspectator API focuses on the constructs a user needs to instrument the\ncode. In spectator the user would always use the registry to create a\n\nCounter\n. The implementation details are left up to the\nregistry.\n\n\nThe \nregistration\n is simpler as well to avoid common pitfalls\nwhen using servo like overwriting a registered object.\n\n\nMore Focused\n\n\nThe goal of spectator is instrumenting code to send to a dimensional\ntime-series system like \nAtlas\n.\nServo has goals of staying compatible with a number of legacy libraries\nand naming formats, exposing data to JMX, etc. Examples of how this\ninfluences decisions:\n\n\n\n\nNo support for non-numeric data. Servo supported this for exposing to JMX.\n  Exposing the numeric data registered in spectator to JMX can be done\n  using a registry that supports it, but there is no goal to be a general\n  interface for exposing arbitrary data in JMX.\n\n\nNo support for customizeable time units when reporting timer data. Base\n  units should always be used for reporting and conversions can be performed\n  in the presentation layer if needed. It also avoids a lot of the confusion\n  around the timer unit for the data and issues like creating aggregates that\n  are meaningless because of mixed units.\n\n\n\n\nIt is better to have a simple way to get correct and easy to reason about\ndata to the backend than many options. If you want more knobs, then you can use\nServo.\n\n\nDI Friendly\n\n\nWhen servo was originally written dependency injection was not heavily used\nat Netflix. Further servo needed to stay compatible with a number of use-cases\nthat were heavily static.\n\n\nWhile spectator does have a static registry that can be used, the recommended\nway is to create a registry and inject it either manually or via a framework\ninto the classes that need it. This also makes it much easier to\n\ntest in isolation\n.\n\n\nMigration\n\n\nIf you want to migrate from the servo API to the spectator API, then this\nsection provides some guides on how servo constructs can be ported over. The\nsub-sections are the class names of monitor types supported by servo.\n\n\nFor users at Netflix, note we are not actively pushing teams to migrate\nor do any additional work. Servo is still supported and if it works for your\nuse-cases feel free to continue using it. \n\n\nRegistration\n\n\nFirst read through the \nservo docs on registration\n. In servo if you have a\nclass like:\n\n\npublic class Foo {\n\n  private AtomicInteger gauge;\n  private Counter counter;\n\n  public Foo(String id) {\n    gauge = new AtomicInteger();\n    counter = new BasicCounter(MonitorConfig.builder(\ncounter\n).build());\n    Monitors.registerObject(id, this);\n  }\n\n  @Monitor(name = \ngauge\n, type = DataSourceType.GAUGE)\n  private int gauge() {\n    return gauge.get();\n  }\n\n  public void doSomething() {\n    ...\n  }\n}\n\n\n\n\nThe state of the class is in the member variables of an instance of \nFoo\n.\nIf multiple instances of class \nFoo\n are created with the same value for \nid\n,\nthen the last one will overwrite the others for the registration. So the\nvalues getting reported will only be from the last instance registered. Also\nthe registry has a reference to the instance of \nFoo\n so it will never go\naway.\n\n\nFor counters and timers one way to get around this is to use\n\nDynamicCounter\n and \nDynamicTimer\n\nrespectively. Those classes will automatically handle the registration and\nexpire if there is no activity. They also get used for cases where the set\nof dimensions is not known up front.\n\n\nGauges need to sample the state of something so they need to have a reference\nto an object that contains the state. So the user would need to ensure that\nonly a single copy was registered leading to patterns like:\n\n\nclass Foo {\n\n  private static class FooStats {\n\n    private AtomicInteger gauge;\n    private Counter counter;\n\n    public FooStats(String id) {\n      gauge = new AtomicInteger();\n      counter = new BasicCounter(MonitorConfig.builder(\ncounter\n).build());\n      Monitors.registerObject(id, this);\n    }\n\n    @Monitor(name = \ngauge\n, type = DataSourceType.GAUGE)\n    private int gauge() {\n      return gauge.get();\n    }\n  }\n\n  private static ConcurrentHashMap\nString, FooStats\n STATS =\n    new ConcurrentHashMap\n();\n\n  private final FooStats stats;\n\n  public Foo(String id) {\n    stats = STATS.computeIfAbsent(id, (i) -\n new FooStats(i));\n  }\n\n  public void doSomething() {\n    ...\n    stats.update();\n  }\n}\n\n\n\n\nThis ensures that there is a single copy for a given id. In spectator this\nexample would look like: \n\n\npublic class Foo {\n\n  private AtomicInteger gauge;\n  private Counter counter;\n\n  public Foo(Registry registry, String id) {\n    Id gaugeId = registry.createId(\ngauge\n).withTag(\nid\n, id);\n    gauge = registry.gauge(gaugeId, new AtomicInteger());\n    counter = registry.counter(\ncounter\n, \nid\n, id);\n  }\n\n  public void doSomething() {\n    ...\n  }\n}\n\n\n\n\nEverything using the same registry will get the same counter\ninstance if the same id is used. For the gauge the registry will\nkeep a weak reference and will sum the values if multiple instances are\npresent. Since it is a weak reference, nothing will prevent an instance of\n\nFoo\n from getting garbage collected.\n\n\nAnnotations\n\n\nAnnotations are not supported, use the appropriate meter type:\n\n\n\n\n\n\n\n\nDataSourceType\n\n\nSpectator Alternative\n\n\n\n\n\n\n\n\n\n\nCOUNTER\n\n\n[[Counter Usage]]\n\n\n\n\n\n\nGAUGE\n\n\n[[Gauge Usage]]\n\n\n\n\n\n\nINFORMATIONAL\n\n\nNot supported\n\n\n\n\n\n\n\n\nBasicCounter\n\n\nSee the general overview of \nregistration differences\n and\nsummary of \ncounter usage\n.\n\n\nServo:\n\n\npublic class Foo {\n  private final Counter c =\n    new BasicCounter(MonitorConfig.builder(\nname\n).build());\n\n  public Foo(String id) {\n    Monitors.registerObject(id, this);\n  }\n\n  public void doSomething() {\n    c.increment();\n  }\n}\n\n\n\n\nSpectator:\n\n\npublic class Foo {\n  private final Counter c;\n\n  @Inject\n  public Foo(Registry registry, String id) {\n    c = registry.counter(\nname\n, \nid\n, id);\n  }\n\n  public void doSomething() {\n    c.increment();\n  }\n}\n\n\n\n\nBasicGauge\n\n\nSee the general overview of \nregistration differences\n and\nsummary of \ngauge usage\n.\n\n\nServo:\n\n\npublic class Foo {\n  private final BasicGauge g = new BasicGauge(\n    MonitorConfig.builder(\nname\n).build(),\n    this::getCurrentValue);\n\n  public Foo(String id) {\n    Monitors.registerObject(id, this);\n  }\n}\n\n\n\n\nSpectator:\n\n\npublic class Foo {\n  @Inject\n  public Foo(Registry registry, String id) {\n    Id gaugeId = registry.createId(\nname\n).withTag(\nid\n, id);\n    registry.gauge(gaugeId, this, Foo::getCurrentValue);\n  }\n}\n\n\n\n\nBasicTimer\n\n\nSee the general overview of \nregistration differences\n and\nsummary of \ntimer usage\n. Note in spectator the reported unit\nfor timers is always seconds and cannot be changed. Seconds is the base unit\nand other units should only be used as a presentation detail. Servo allows\nthe unit to be customized and defaults to milliseconds.\n\n\nServo:\n\n\npublic class Foo {\n  private final Timer t = new BasicTimer(\n    MonitorConfig.builder(\nname\n).build(), TimeUnit.SECONDS);\n\n  public Foo(String id) {\n    Monitors.registerObject(id, this);\n  }\n\n  public void doSomething() {\n    Stopwatch s = t.start();\n    try {\n      ...\n    } finally {\n      s.stop();\n    }\n  }\n}\n\n\n\n\nSpectator:\n\n\npublic class Foo {\n  private final Timer t;\n\n  @Inject\n  public Foo(Registry registry, String id) {\n    t = registry.timer(\nname\n, \nid\n, id);\n  }\n\n  public void doSomething() {\n    t.record(() -\n {\n      ...\n    });\n  }\n}\n\n\n\n\nBasicDistributionSummary\n\n\nSee the general overview of \nregistration differences\n and\nsummary of \ndistribution summary usage\n.\n\n\nServo:\n\n\npublic class Foo {\n  private final BasicDistributionSummary s = new BasicDistributionSummary(\n    MonitorConfig.builder(\nname\n).build());\n\n  public Foo(String id) {\n    Monitors.registerObject(id, this);\n  }\n\n  public void doSomething() {\n    ...\n    s.record(getValue());\n  }\n}\n\n\n\n\nSpectator:\n\n\npublic class Foo {\n  private final DistributionSummary s;\n\n  @Inject\n  public Foo(Registry registry, String id) {\n    s = registry.distributionSummary(\nname\n, \nid\n, id);\n  }\n\n  public void doSomething() {\n    ...\n    s.record(getValue());\n  }\n}\n\n\n\n\nBasicInformational\n\n\nNot supported, see \noverview of differences\n.\n\n\nBasicStopwatch\n\n\nThere isn't an explicit stopwatch class in spectator. Just use a timing\ncall directly. \n\n\nServo:\n\n\n  public void doSomething() {\n    Stopwatch s = timer.start();\n    try {\n      ...\n    } finally {\n      s.stop();\n    }\n  }\n\n\n\n\nSpectator:\n\n\n  public void doSomething() {\n    final long s = System.nanoTime();\n    try {\n      ...\n    } finally {\n      timer.record(System.nanoTime() - s, TimeUnit.NANOSECONDS);\n    }\n  }\n\n\n\n\nBucketTimer\n\n\nSee the general overview of \nregistration differences\n and\nsummary of \nsandbox documentation\n. Note in spectator BucketTimer is\nprovided in the sandbox extension library and may change in future as we\ngain more experience using it.\n\n\nServo:\n\n\npublic class Foo {\n  private final Timer t = new BucketTimer(\n    MonitorConfig.builder(\nname\n).build(),\n    new BucketConfig.Builder()\n      .withTimeUnit(TimeUnit.MILLISECONDS)\n      .withBuckets(new long[] { 500, 2500, 5000, 10000 })\n      .build());\n\n  public Foo(String id) {\n    Monitors.registerObject(id, this);\n  }\n\n  public void doSomething() {\n    Stopwatch s = t.start();\n    try {\n      ...\n    } finally {\n      s.stop();\n    }\n  }\n}\n\n\n\n\nSpectator:\n\n\npublic class Foo {\n  private final Timer t;\n\n  @Inject\n  public Foo(Registry registry, String id) {\n    Id timerId = registry.createId(\nname\n, \nid\n, id);\n    BucketFunction f = BucketFunctions.latency(10, TimeUnit.SECONDS);\n    t = BucketTimer.get(registry, timerId, f);\n  }\n\n  public void doSomething() {\n    t.record(() -\n {\n      ...\n    });\n  }\n}\n\n\n\n\nContextualCounter\n\n\nNot supported. A fixed tag list for the context is too rigid and this class\nwas never used much at Netflix. Future work being looked at in\n\nissue-180\n.\n\n\nContextualTimer\n\n\nNot supported. A fixed tag list for the context is too rigid and this class\nwas never used much at Netflix. Future work being looked at in\n\nissue-180\n.\n\n\nDoubleGauge\n\n\nSee the general overview of \nregistration differences\n and\nsummary of \ngauge usage\n.\n\n\nServo:\n\n\npublic class Foo {\n  private final DoubleGauge g = new DoubleGauge(\n    MonitorConfig.builder(\nname\n).build());\n\n  public Foo(String id) {\n    Monitors.registerObject(id, this);\n  }\n}\n\n\n\n\nSpectator:\n\n\nimport com.google.common.util.concurrent.AtomicDouble;\n\npublic class Foo {\n  private final AtomicDouble v;\n\n  @Inject\n  public Foo(Registry registry, String id) {\n    Id gaugeId = registry.createId(\nname\n).withTag(\nid\n, id);\n    v = registry.gauge(gaugeId, new AtomicDouble());\n  }\n}\n\n\n\n\nDurationTimer\n\n\nSee the general overview of \nregistration differences\n and\nsummary of \ntimer usage\n.\n\n\nServo:\n\n\npublic class Foo {\n  private final DurationTimer t = new DurationTimer(\n    MonitorConfig.builder(\nname\n).build());\n\n  public Foo(String id) {\n    Monitors.registerObject(id, this);\n  }\n}\n\n\n\n\nSpectator:\n\n\npublic class Foo {\n  private final LongTaskTimer t;\n\n  @Inject\n  public Foo(Registry registry, String id) {\n    t = registry.longTaskTimer(\nname\n, \nid\n, id);\n  }\n}\n\n\n\n\nDynamicCounter\n\n\nSee the general overview of \nregistration differences\n and\nsummary of \ncounter usage\n.\n\n\nServo:\n\n\npublic class Foo {\n\n  private final String id;\n\n  public Foo(String id) {\n    this.id = id;\n  }\n\n  public void doSomething(Context ctxt) {\n    DynamicCounter.increment(\nstaticId\n, \nid\n, id);\n    DynamicCounter.increment(\ndynamicId\n, \nid\n, id, \nfoo\n, ctxt.getFoo());\n  }\n}\n\n\n\n\nSpectator:\n\n\npublic class Foo {\n  private final Registry registry;\n  private final String id;\n  private final Counter staticCounter;\n  private final Id dynamicId;\n\n  @Inject\n  public Foo(Registry registry, String id) {\n    this.registry = registry;\n    this.id = id;\n    staticCounter = registry.counter(\nstaticId\n, \nid\n, id);\n    dynamicId = registry.createId(\ndynamicId\n, \nid\n, id);\n  }\n\n  public void doSomething(Context ctxt) {\n    // Keeping the reference to the counter avoids additional allocations\n    // to create the id object and the lookup cost\n    staticCounter.increment();\n\n    // If the id is dynamic it must be looked up\n    registry.counter(\ndynamicId\n, \nid\n, id, \nfoo\n, ctxt.getFoo()).increment();\n\n    // This will update the same counter as the line above, but the base part\n    // of the id is precomputed to make it cheaper to construct the id.\n    registry.counter(dynamicId.withTag(\nfoo\n, ctxt.getFoo())).increment();\n  }\n}\n\n\n\n\nDynamicTimer\n\n\nSee the general overview of \nregistration differences\n and\nsummary of \ntimer usage\n.\n\n\nServo:\n\n\npublic class Foo {\n\n  private final String id;\n  private final MonitorConfig staticId;\n\n  public Foo(String id) {\n    this.id = id;\n    staticId = MonitorConfig.builder(\nstaticId\n).withTag(\nid\n, id).build();\n  }\n\n  public void doSomething(Context ctxt) {\n    final long d = ctxt.getDurationMillis();\n    DynamicTimer.record(staticId, TimeUnit.SECONDS, d, TimeUnit.MILLISECONDS);\n\n    MonitorConfig dynamicId = MonitorConfig.builder(\ndynamicId\n)\n      .withTag(\nid\n, id)\n      .withTag(\nfoo\n, ctxt.getFoo())\n      .build();\n    DynamicTimer.record(dynamicId, TimeUnit.SECONDS, d, TimeUnit.MILLISECONDS);\n  }\n}\n\n\n\n\nSpectator:\n\n\npublic class Foo {\n  private final Registry registry;\n  private final String id;\n  private final Timer staticTimer;\n  private final Id dynamicId;\n\n  @Inject\n  public Foo(Registry registry, String id) {\n    this.registry = registry;\n    this.id = id;\n    staticTimer = registry.timer(\nstaticId\n, \nid\n, id);\n    dynamicId = registry.createId(\ndynamicId\n, \nid\n, id);\n  }\n\n  public void doSomething(Context ctxt) {\n    final long d = ctxt.getDurationMillis();\n\n    // Keeping the reference to the timer avoids additional allocations\n    // to create the id object and the lookup cost\n    staticTimer.record(d, TimeUnit.MILLISECONDS);\n\n    // If the id is dynamic it must be looked up\n    registry.timer(\ndynamicId\n, \nid\n, id, \nfoo\n, ctxt.getFoo())\n      .record(d, TimeUnit.MILLISECONDS);\n\n    // This will update the same timer as the line above, but the base part\n    // of the id is precomputed to make it cheaper to construct the id.\n    registry.timer(dynamicId.withTag(\nfoo\n, ctxt.getFoo()))\n      .record(d, TimeUnit.MILLISECONDS);\n  }\n}\n\n\n\n\nLongGauge\n\n\nSee the general overview of \nregistration differences\n and\nsummary of \ngauge usage\n.\n\n\nServo:\n\n\npublic class Foo {\n  private final LongGauge g = new LongGauge(\n    MonitorConfig.builder(\nname\n).build());\n\n  public Foo(String id) {\n    Monitors.registerObject(id, this);\n  }\n}\n\n\n\n\nSpectator:\n\n\npublic class Foo {\n  private final AtomicLong v;\n\n  @Inject\n  public Foo(Registry registry, String id) {\n    Id gaugeId = registry.createId(\nname\n).withTag(\nid\n, id);\n    v = registry.gauge(gaugeId, new AtomicLong());\n  }\n}\n\n\n\n\nMonitorConfig\n\n\nSee the documentation on \nnaming\n.\n\n\nServo:\n\n\nMonitorConfig id = MonitorConfig.builder(\nname\n)\n  .withTag(\ncountry\n, \nUS\n)\n  .withTag(\ndevice\n,  \nxbox\n)\n  .build();\n\n\n\n\nSpectator:\n\n\nId id = registry.createId(\nname\n)\n  .withTag(\ncountry\n, \nUS\n)\n  .withTag(\ndevice\n,  \nxbox\n);\n\n// or\n\nId id = registry.createId(\nname\n, \ncountry\n, \nUS\n, \ndevice\n, \nxbox\n);\n\n\n\n\nMonitoredCache\n\n\nNot supported because spectator does not have a direct dependency on guava.\nIf there is enough demand an extension can be created.\n\n\nNumberGauge\n\n\nSee the general overview of \nregistration differences\n and\nsummary of \ngauge usage\n.\n\n\nServo:\n\n\npublic class Foo {\n  private final NumberGauge g = new NumberGauge(\n    MonitorConfig.builder(\nname\n).build(), new AtomicLong());\n\n  public Foo(String id) {\n    Monitors.registerObject(id, this);\n  }\n}\n\n\n\n\nSpectator:\n\n\npublic class Foo {\n  private final AtomicLong v;\n\n  @Inject\n  public Foo(Registry registry, String id) {\n    Id gaugeId = registry.createId(\nname\n).withTag(\nid\n, id);\n    v = registry.gauge(gaugeId, new AtomicLong());\n  }\n}\n\n\n\n\nStatsTimer\n\n\nNot supported, see \noverview of differences\n.\n\n\nStepCounter\n\n\nSee the general overview of \nregistration differences\n and\nsummary of \ncounter usage\n.\n\n\nServo:\n\n\npublic class Foo {\n  private final Counter c =\n    new StepCounter(MonitorConfig.builder(\nname\n).build());\n\n  public Foo(String id) {\n    Monitors.registerObject(id, this);\n  }\n\n  public void doSomething() {\n    c.increment();\n  }\n}\n\n\n\n\nSpectator:\n\n\npublic class Foo {\n  private final Counter c;\n\n  @Inject\n  public Foo(Registry registry, String id) {\n    c = registry.counter(\nname\n, \nid\n, id);\n  }\n\n  public void doSomething() {\n    c.increment();\n  }\n}", 
            "title": "Servo Comparison"
        }, 
        {
            "location": "/intro/servo-comparison/#servo-comparison", 
            "text": "Servo  is an alternative client monitoring\nlibrary that is also developed by Netflix. Originally spectator was an\nexperiment for a simpler API that wrapped servo. It was done as a separate\nproject to avoid breaking backwards compatibility for servo.  From a user perspective, both will be supported for a long time, but most\nof our efforts for future improvement will go to spectator. For new code it\nis recommended to use the spectator API. If running at Netflix  the correct bindings will be in place\nfor both servo and spectator.", 
            "title": "Servo Comparison"
        }, 
        {
            "location": "/intro/servo-comparison/#differences", 
            "text": "This section provides a quick summary of the differences.", 
            "title": "Differences"
        }, 
        {
            "location": "/intro/servo-comparison/#simpler-api", 
            "text": "Servo gives the user a lot of control, but this makes it hard to use\ncorrectly. For example, to create a counter the user needs to understand\nthe tradeoffs and choose between:   BasicCounter  DynamicCounter  ContextualCounter  StepCounter   Further each of these can impact how data is reported to observers. The\nspectator API focuses on the constructs a user needs to instrument the\ncode. In spectator the user would always use the registry to create a Counter . The implementation details are left up to the\nregistry.  The  registration  is simpler as well to avoid common pitfalls\nwhen using servo like overwriting a registered object.", 
            "title": "Simpler API"
        }, 
        {
            "location": "/intro/servo-comparison/#more-focused", 
            "text": "The goal of spectator is instrumenting code to send to a dimensional\ntime-series system like  Atlas .\nServo has goals of staying compatible with a number of legacy libraries\nand naming formats, exposing data to JMX, etc. Examples of how this\ninfluences decisions:   No support for non-numeric data. Servo supported this for exposing to JMX.\n  Exposing the numeric data registered in spectator to JMX can be done\n  using a registry that supports it, but there is no goal to be a general\n  interface for exposing arbitrary data in JMX.  No support for customizeable time units when reporting timer data. Base\n  units should always be used for reporting and conversions can be performed\n  in the presentation layer if needed. It also avoids a lot of the confusion\n  around the timer unit for the data and issues like creating aggregates that\n  are meaningless because of mixed units.   It is better to have a simple way to get correct and easy to reason about\ndata to the backend than many options. If you want more knobs, then you can use\nServo.", 
            "title": "More Focused"
        }, 
        {
            "location": "/intro/servo-comparison/#di-friendly", 
            "text": "When servo was originally written dependency injection was not heavily used\nat Netflix. Further servo needed to stay compatible with a number of use-cases\nthat were heavily static.  While spectator does have a static registry that can be used, the recommended\nway is to create a registry and inject it either manually or via a framework\ninto the classes that need it. This also makes it much easier to test in isolation .", 
            "title": "DI Friendly"
        }, 
        {
            "location": "/intro/servo-comparison/#migration", 
            "text": "If you want to migrate from the servo API to the spectator API, then this\nsection provides some guides on how servo constructs can be ported over. The\nsub-sections are the class names of monitor types supported by servo.  For users at Netflix, note we are not actively pushing teams to migrate\nor do any additional work. Servo is still supported and if it works for your\nuse-cases feel free to continue using it.", 
            "title": "Migration"
        }, 
        {
            "location": "/intro/servo-comparison/#registration", 
            "text": "First read through the  servo docs on registration . In servo if you have a\nclass like:  public class Foo {\n\n  private AtomicInteger gauge;\n  private Counter counter;\n\n  public Foo(String id) {\n    gauge = new AtomicInteger();\n    counter = new BasicCounter(MonitorConfig.builder( counter ).build());\n    Monitors.registerObject(id, this);\n  }\n\n  @Monitor(name =  gauge , type = DataSourceType.GAUGE)\n  private int gauge() {\n    return gauge.get();\n  }\n\n  public void doSomething() {\n    ...\n  }\n}  The state of the class is in the member variables of an instance of  Foo .\nIf multiple instances of class  Foo  are created with the same value for  id ,\nthen the last one will overwrite the others for the registration. So the\nvalues getting reported will only be from the last instance registered. Also\nthe registry has a reference to the instance of  Foo  so it will never go\naway.  For counters and timers one way to get around this is to use DynamicCounter  and  DynamicTimer \nrespectively. Those classes will automatically handle the registration and\nexpire if there is no activity. They also get used for cases where the set\nof dimensions is not known up front.  Gauges need to sample the state of something so they need to have a reference\nto an object that contains the state. So the user would need to ensure that\nonly a single copy was registered leading to patterns like:  class Foo {\n\n  private static class FooStats {\n\n    private AtomicInteger gauge;\n    private Counter counter;\n\n    public FooStats(String id) {\n      gauge = new AtomicInteger();\n      counter = new BasicCounter(MonitorConfig.builder( counter ).build());\n      Monitors.registerObject(id, this);\n    }\n\n    @Monitor(name =  gauge , type = DataSourceType.GAUGE)\n    private int gauge() {\n      return gauge.get();\n    }\n  }\n\n  private static ConcurrentHashMap String, FooStats  STATS =\n    new ConcurrentHashMap ();\n\n  private final FooStats stats;\n\n  public Foo(String id) {\n    stats = STATS.computeIfAbsent(id, (i) -  new FooStats(i));\n  }\n\n  public void doSomething() {\n    ...\n    stats.update();\n  }\n}  This ensures that there is a single copy for a given id. In spectator this\nexample would look like:   public class Foo {\n\n  private AtomicInteger gauge;\n  private Counter counter;\n\n  public Foo(Registry registry, String id) {\n    Id gaugeId = registry.createId( gauge ).withTag( id , id);\n    gauge = registry.gauge(gaugeId, new AtomicInteger());\n    counter = registry.counter( counter ,  id , id);\n  }\n\n  public void doSomething() {\n    ...\n  }\n}  Everything using the same registry will get the same counter\ninstance if the same id is used. For the gauge the registry will\nkeep a weak reference and will sum the values if multiple instances are\npresent. Since it is a weak reference, nothing will prevent an instance of Foo  from getting garbage collected.", 
            "title": "Registration"
        }, 
        {
            "location": "/intro/servo-comparison/#annotations", 
            "text": "Annotations are not supported, use the appropriate meter type:     DataSourceType  Spectator Alternative      COUNTER  [[Counter Usage]]    GAUGE  [[Gauge Usage]]    INFORMATIONAL  Not supported", 
            "title": "Annotations"
        }, 
        {
            "location": "/intro/servo-comparison/#basiccounter", 
            "text": "See the general overview of  registration differences  and\nsummary of  counter usage .  Servo:  public class Foo {\n  private final Counter c =\n    new BasicCounter(MonitorConfig.builder( name ).build());\n\n  public Foo(String id) {\n    Monitors.registerObject(id, this);\n  }\n\n  public void doSomething() {\n    c.increment();\n  }\n}  Spectator:  public class Foo {\n  private final Counter c;\n\n  @Inject\n  public Foo(Registry registry, String id) {\n    c = registry.counter( name ,  id , id);\n  }\n\n  public void doSomething() {\n    c.increment();\n  }\n}", 
            "title": "BasicCounter"
        }, 
        {
            "location": "/intro/servo-comparison/#basicgauge", 
            "text": "See the general overview of  registration differences  and\nsummary of  gauge usage .  Servo:  public class Foo {\n  private final BasicGauge g = new BasicGauge(\n    MonitorConfig.builder( name ).build(),\n    this::getCurrentValue);\n\n  public Foo(String id) {\n    Monitors.registerObject(id, this);\n  }\n}  Spectator:  public class Foo {\n  @Inject\n  public Foo(Registry registry, String id) {\n    Id gaugeId = registry.createId( name ).withTag( id , id);\n    registry.gauge(gaugeId, this, Foo::getCurrentValue);\n  }\n}", 
            "title": "BasicGauge"
        }, 
        {
            "location": "/intro/servo-comparison/#basictimer", 
            "text": "See the general overview of  registration differences  and\nsummary of  timer usage . Note in spectator the reported unit\nfor timers is always seconds and cannot be changed. Seconds is the base unit\nand other units should only be used as a presentation detail. Servo allows\nthe unit to be customized and defaults to milliseconds.  Servo:  public class Foo {\n  private final Timer t = new BasicTimer(\n    MonitorConfig.builder( name ).build(), TimeUnit.SECONDS);\n\n  public Foo(String id) {\n    Monitors.registerObject(id, this);\n  }\n\n  public void doSomething() {\n    Stopwatch s = t.start();\n    try {\n      ...\n    } finally {\n      s.stop();\n    }\n  }\n}  Spectator:  public class Foo {\n  private final Timer t;\n\n  @Inject\n  public Foo(Registry registry, String id) {\n    t = registry.timer( name ,  id , id);\n  }\n\n  public void doSomething() {\n    t.record(() -  {\n      ...\n    });\n  }\n}", 
            "title": "BasicTimer"
        }, 
        {
            "location": "/intro/servo-comparison/#basicdistributionsummary", 
            "text": "See the general overview of  registration differences  and\nsummary of  distribution summary usage .  Servo:  public class Foo {\n  private final BasicDistributionSummary s = new BasicDistributionSummary(\n    MonitorConfig.builder( name ).build());\n\n  public Foo(String id) {\n    Monitors.registerObject(id, this);\n  }\n\n  public void doSomething() {\n    ...\n    s.record(getValue());\n  }\n}  Spectator:  public class Foo {\n  private final DistributionSummary s;\n\n  @Inject\n  public Foo(Registry registry, String id) {\n    s = registry.distributionSummary( name ,  id , id);\n  }\n\n  public void doSomething() {\n    ...\n    s.record(getValue());\n  }\n}", 
            "title": "BasicDistributionSummary"
        }, 
        {
            "location": "/intro/servo-comparison/#basicinformational", 
            "text": "Not supported, see  overview of differences .", 
            "title": "BasicInformational"
        }, 
        {
            "location": "/intro/servo-comparison/#basicstopwatch", 
            "text": "There isn't an explicit stopwatch class in spectator. Just use a timing\ncall directly.   Servo:    public void doSomething() {\n    Stopwatch s = timer.start();\n    try {\n      ...\n    } finally {\n      s.stop();\n    }\n  }  Spectator:    public void doSomething() {\n    final long s = System.nanoTime();\n    try {\n      ...\n    } finally {\n      timer.record(System.nanoTime() - s, TimeUnit.NANOSECONDS);\n    }\n  }", 
            "title": "BasicStopwatch"
        }, 
        {
            "location": "/intro/servo-comparison/#buckettimer", 
            "text": "See the general overview of  registration differences  and\nsummary of  sandbox documentation . Note in spectator BucketTimer is\nprovided in the sandbox extension library and may change in future as we\ngain more experience using it.  Servo:  public class Foo {\n  private final Timer t = new BucketTimer(\n    MonitorConfig.builder( name ).build(),\n    new BucketConfig.Builder()\n      .withTimeUnit(TimeUnit.MILLISECONDS)\n      .withBuckets(new long[] { 500, 2500, 5000, 10000 })\n      .build());\n\n  public Foo(String id) {\n    Monitors.registerObject(id, this);\n  }\n\n  public void doSomething() {\n    Stopwatch s = t.start();\n    try {\n      ...\n    } finally {\n      s.stop();\n    }\n  }\n}  Spectator:  public class Foo {\n  private final Timer t;\n\n  @Inject\n  public Foo(Registry registry, String id) {\n    Id timerId = registry.createId( name ,  id , id);\n    BucketFunction f = BucketFunctions.latency(10, TimeUnit.SECONDS);\n    t = BucketTimer.get(registry, timerId, f);\n  }\n\n  public void doSomething() {\n    t.record(() -  {\n      ...\n    });\n  }\n}", 
            "title": "BucketTimer"
        }, 
        {
            "location": "/intro/servo-comparison/#contextualcounter", 
            "text": "Not supported. A fixed tag list for the context is too rigid and this class\nwas never used much at Netflix. Future work being looked at in issue-180 .", 
            "title": "ContextualCounter"
        }, 
        {
            "location": "/intro/servo-comparison/#contextualtimer", 
            "text": "Not supported. A fixed tag list for the context is too rigid and this class\nwas never used much at Netflix. Future work being looked at in issue-180 .", 
            "title": "ContextualTimer"
        }, 
        {
            "location": "/intro/servo-comparison/#doublegauge", 
            "text": "See the general overview of  registration differences  and\nsummary of  gauge usage .  Servo:  public class Foo {\n  private final DoubleGauge g = new DoubleGauge(\n    MonitorConfig.builder( name ).build());\n\n  public Foo(String id) {\n    Monitors.registerObject(id, this);\n  }\n}  Spectator:  import com.google.common.util.concurrent.AtomicDouble;\n\npublic class Foo {\n  private final AtomicDouble v;\n\n  @Inject\n  public Foo(Registry registry, String id) {\n    Id gaugeId = registry.createId( name ).withTag( id , id);\n    v = registry.gauge(gaugeId, new AtomicDouble());\n  }\n}", 
            "title": "DoubleGauge"
        }, 
        {
            "location": "/intro/servo-comparison/#durationtimer", 
            "text": "See the general overview of  registration differences  and\nsummary of  timer usage .  Servo:  public class Foo {\n  private final DurationTimer t = new DurationTimer(\n    MonitorConfig.builder( name ).build());\n\n  public Foo(String id) {\n    Monitors.registerObject(id, this);\n  }\n}  Spectator:  public class Foo {\n  private final LongTaskTimer t;\n\n  @Inject\n  public Foo(Registry registry, String id) {\n    t = registry.longTaskTimer( name ,  id , id);\n  }\n}", 
            "title": "DurationTimer"
        }, 
        {
            "location": "/intro/servo-comparison/#dynamiccounter", 
            "text": "See the general overview of  registration differences  and\nsummary of  counter usage .  Servo:  public class Foo {\n\n  private final String id;\n\n  public Foo(String id) {\n    this.id = id;\n  }\n\n  public void doSomething(Context ctxt) {\n    DynamicCounter.increment( staticId ,  id , id);\n    DynamicCounter.increment( dynamicId ,  id , id,  foo , ctxt.getFoo());\n  }\n}  Spectator:  public class Foo {\n  private final Registry registry;\n  private final String id;\n  private final Counter staticCounter;\n  private final Id dynamicId;\n\n  @Inject\n  public Foo(Registry registry, String id) {\n    this.registry = registry;\n    this.id = id;\n    staticCounter = registry.counter( staticId ,  id , id);\n    dynamicId = registry.createId( dynamicId ,  id , id);\n  }\n\n  public void doSomething(Context ctxt) {\n    // Keeping the reference to the counter avoids additional allocations\n    // to create the id object and the lookup cost\n    staticCounter.increment();\n\n    // If the id is dynamic it must be looked up\n    registry.counter( dynamicId ,  id , id,  foo , ctxt.getFoo()).increment();\n\n    // This will update the same counter as the line above, but the base part\n    // of the id is precomputed to make it cheaper to construct the id.\n    registry.counter(dynamicId.withTag( foo , ctxt.getFoo())).increment();\n  }\n}", 
            "title": "DynamicCounter"
        }, 
        {
            "location": "/intro/servo-comparison/#dynamictimer", 
            "text": "See the general overview of  registration differences  and\nsummary of  timer usage .  Servo:  public class Foo {\n\n  private final String id;\n  private final MonitorConfig staticId;\n\n  public Foo(String id) {\n    this.id = id;\n    staticId = MonitorConfig.builder( staticId ).withTag( id , id).build();\n  }\n\n  public void doSomething(Context ctxt) {\n    final long d = ctxt.getDurationMillis();\n    DynamicTimer.record(staticId, TimeUnit.SECONDS, d, TimeUnit.MILLISECONDS);\n\n    MonitorConfig dynamicId = MonitorConfig.builder( dynamicId )\n      .withTag( id , id)\n      .withTag( foo , ctxt.getFoo())\n      .build();\n    DynamicTimer.record(dynamicId, TimeUnit.SECONDS, d, TimeUnit.MILLISECONDS);\n  }\n}  Spectator:  public class Foo {\n  private final Registry registry;\n  private final String id;\n  private final Timer staticTimer;\n  private final Id dynamicId;\n\n  @Inject\n  public Foo(Registry registry, String id) {\n    this.registry = registry;\n    this.id = id;\n    staticTimer = registry.timer( staticId ,  id , id);\n    dynamicId = registry.createId( dynamicId ,  id , id);\n  }\n\n  public void doSomething(Context ctxt) {\n    final long d = ctxt.getDurationMillis();\n\n    // Keeping the reference to the timer avoids additional allocations\n    // to create the id object and the lookup cost\n    staticTimer.record(d, TimeUnit.MILLISECONDS);\n\n    // If the id is dynamic it must be looked up\n    registry.timer( dynamicId ,  id , id,  foo , ctxt.getFoo())\n      .record(d, TimeUnit.MILLISECONDS);\n\n    // This will update the same timer as the line above, but the base part\n    // of the id is precomputed to make it cheaper to construct the id.\n    registry.timer(dynamicId.withTag( foo , ctxt.getFoo()))\n      .record(d, TimeUnit.MILLISECONDS);\n  }\n}", 
            "title": "DynamicTimer"
        }, 
        {
            "location": "/intro/servo-comparison/#longgauge", 
            "text": "See the general overview of  registration differences  and\nsummary of  gauge usage .  Servo:  public class Foo {\n  private final LongGauge g = new LongGauge(\n    MonitorConfig.builder( name ).build());\n\n  public Foo(String id) {\n    Monitors.registerObject(id, this);\n  }\n}  Spectator:  public class Foo {\n  private final AtomicLong v;\n\n  @Inject\n  public Foo(Registry registry, String id) {\n    Id gaugeId = registry.createId( name ).withTag( id , id);\n    v = registry.gauge(gaugeId, new AtomicLong());\n  }\n}", 
            "title": "LongGauge"
        }, 
        {
            "location": "/intro/servo-comparison/#monitorconfig", 
            "text": "See the documentation on  naming .  Servo:  MonitorConfig id = MonitorConfig.builder( name )\n  .withTag( country ,  US )\n  .withTag( device ,   xbox )\n  .build();  Spectator:  Id id = registry.createId( name )\n  .withTag( country ,  US )\n  .withTag( device ,   xbox );\n\n// or\n\nId id = registry.createId( name ,  country ,  US ,  device ,  xbox );", 
            "title": "MonitorConfig"
        }, 
        {
            "location": "/intro/servo-comparison/#monitoredcache", 
            "text": "Not supported because spectator does not have a direct dependency on guava.\nIf there is enough demand an extension can be created.", 
            "title": "MonitoredCache"
        }, 
        {
            "location": "/intro/servo-comparison/#numbergauge", 
            "text": "See the general overview of  registration differences  and\nsummary of  gauge usage .  Servo:  public class Foo {\n  private final NumberGauge g = new NumberGauge(\n    MonitorConfig.builder( name ).build(), new AtomicLong());\n\n  public Foo(String id) {\n    Monitors.registerObject(id, this);\n  }\n}  Spectator:  public class Foo {\n  private final AtomicLong v;\n\n  @Inject\n  public Foo(Registry registry, String id) {\n    Id gaugeId = registry.createId( name ).withTag( id , id);\n    v = registry.gauge(gaugeId, new AtomicLong());\n  }\n}", 
            "title": "NumberGauge"
        }, 
        {
            "location": "/intro/servo-comparison/#statstimer", 
            "text": "Not supported, see  overview of differences .", 
            "title": "StatsTimer"
        }, 
        {
            "location": "/intro/servo-comparison/#stepcounter", 
            "text": "See the general overview of  registration differences  and\nsummary of  counter usage .  Servo:  public class Foo {\n  private final Counter c =\n    new StepCounter(MonitorConfig.builder( name ).build());\n\n  public Foo(String id) {\n    Monitors.registerObject(id, this);\n  }\n\n  public void doSomething() {\n    c.increment();\n  }\n}  Spectator:  public class Foo {\n  private final Counter c;\n\n  @Inject\n  public Foo(Registry registry, String id) {\n    c = registry.counter( name ,  id , id);\n  }\n\n  public void doSomething() {\n    c.increment();\n  }\n}", 
            "title": "StepCounter"
        }, 
        {
            "location": "/ext/jvm-buffer-pools/", 
            "text": "Buffer Pools\n\n\nBuffer pools, such as direct byte buffers, can be monitored at a high level using the \nBufferPoolMXBean\n provided by the JDK. \n\n\nGetting Started\n\n\nTo get information about buffer pools in spectator just setup registration of standard MXBeans. Note, if you are building an app at Netflix this should happen automatically via the normal platform initialization.\n\n\nimport com.netflix.spectator.api.Spectator;\nimport com.netflix.spectator.jvm.Jmx;\n\nJmx.registerStandardMXBeans(Spectator.registry());\n\n\n\n\nMetrics\n\n\njvm.buffer.count\n\n\nGauge showing the current number of distinct buffers.\n\n\nUnit:\n count \n\n\nDimensions:\n\n\n\n\nid\n: type of buffers. Value will be either \ndirect\n for direct byte buffers or \nmapped\n for memory mapped files.\n\n\n\n\njvm.buffer.memoryUsed\n\n\nGauge showing the current number of bytes used by all buffers.\n\n\nUnit:\n bytes \n\n\nDimensions:\n\n\n\n\nid\n: type of buffers. Value will be either \ndirect\n for direct byte buffers or \nmapped\n for memory mapped files.", 
            "title": "Buffer Pools"
        }, 
        {
            "location": "/ext/jvm-buffer-pools/#buffer-pools", 
            "text": "Buffer pools, such as direct byte buffers, can be monitored at a high level using the  BufferPoolMXBean  provided by the JDK.", 
            "title": "Buffer Pools"
        }, 
        {
            "location": "/ext/jvm-buffer-pools/#getting-started", 
            "text": "To get information about buffer pools in spectator just setup registration of standard MXBeans. Note, if you are building an app at Netflix this should happen automatically via the normal platform initialization.  import com.netflix.spectator.api.Spectator;\nimport com.netflix.spectator.jvm.Jmx;\n\nJmx.registerStandardMXBeans(Spectator.registry());", 
            "title": "Getting Started"
        }, 
        {
            "location": "/ext/jvm-buffer-pools/#metrics", 
            "text": "", 
            "title": "Metrics"
        }, 
        {
            "location": "/ext/jvm-buffer-pools/#jvmbuffercount", 
            "text": "Gauge showing the current number of distinct buffers.  Unit:  count   Dimensions:   id : type of buffers. Value will be either  direct  for direct byte buffers or  mapped  for memory mapped files.", 
            "title": "jvm.buffer.count"
        }, 
        {
            "location": "/ext/jvm-buffer-pools/#jvmbuffermemoryused", 
            "text": "Gauge showing the current number of bytes used by all buffers.  Unit:  bytes   Dimensions:   id : type of buffers. Value will be either  direct  for direct byte buffers or  mapped  for memory mapped files.", 
            "title": "jvm.buffer.memoryUsed"
        }, 
        {
            "location": "/ext/jvm-gc/", 
            "text": "Garbage Collection\n\n\nThe GC module registers with the notification emitter of the \nGarbageCollectorMXBean\n to provide some basic GC logging and metrics.\n\n\n\n\nGetting started\n\n\nLogging\n\n\nMetrics\n\n\nAlerting\n\n\n\n\nGetting Started\n\n\nFor using it internally at Netflix see the [[Netflix integration]] guide, otherwise keep reading this section.\n\n\nRequirements\n\n\nThis library relies on the notification emitter added in 7u4, but there are known issues prior to 7u40. For G1 it is recommended to be on the latest version available.\n\n\nDependencies\n\n\ncom.netflix.spectator:spectator-ext-gc:0.35.0\n\n\n\n\nStart Reporting\n\n\nThen in the initialization for the application:\n\n\nimport com.netflix.spectator.gc.GcLogger;\n...\n// Keep a single instance of the logger\nGcLogger gc = new GcLogger();\ngc.start(null);\n\n\n\n\nLogging\n\n\nAfter GC events an INFO level log message will get reported using slf4j. This makes it easy to GC events in the context of other log messages for the application. The logger name is \ncom.netflix.spectator.gc.GcLogger\n and the message will look like:\n\n\n${GC_TYPE}: ${COLLECTOR_NAME}, id=${N}, at=${START_TIME}, duration=${T}ms, cause=[${CAUSE}], ${TOTAL_USAGE_BEFORE} =\n ${TOTAL_USAGE_AFTER} / ${MAX_SIZE} (${PERCENT_USAGE_BEFORE} =\n ${PERCENT_USAGE_AFTER})\n\n\n\n\nThe id can be used to verify events were not skipped or correlate with other sources like detailed GC logs. See [[GC causes]] for more details on the possible causes.\n\n\nSample:\n\n\n2014-08-31 02:02:24,724  INFO [com.netflix.spectator.gc.GcLogger] YOUNG: ParNew, id=5281, at=Sun Aug 31 02:02:24 UTC 2014, duration=2ms, cause=[Allocation Failure], 0.4G =\n 0.3G / 1.8G (24.3% =\n 16.6%)\n\n\n\n\nMetrics\n\n\njvm.gc.allocationRate\n\n\nThe allocation rate measures how fast the application is allocating memory. It is a counter that is incremented after a GC event by the amount \nyoungGen.sizeBeforeGC\n. Technically, right now it is:\n\n\nyoungGen.sizeBeforeGC - youngGen.sizeAfterGC\n\n\nHowever, \nyoungGen.sizeAfterGC\n should be 0 and thus the size of young gen before the GC is the amount allocated since the previous GC event.\n\n\nUnit:\n bytes/second\n\n\nDimensions:\n n/a\n\n\njvm.gc.promotionRate\n\n\nThe promotion rate measures how fast data is being moved from young generation into the old generation. It is a counter that is incremented after a GC event by the amount:\n\n\nabs(oldGen.sizeAfterGC - oldGen.sizeBeforeGC)\n\n\nUnit:\n bytes/second\n\n\nDimensions:\n n/a\n\n\njvm.gc.liveDataSize\n\n\nThe live data size is the size of the old generation after a major GC. The image below shows how the live data size view compares to a metric showing the current size of the memory pool:\n\n\n\n\nUnit:\n bytes\n\n\nDimensions:\n n/a\n\n\njvm.gc.maxDataSize\n\n\nMaximum size for the old generation. Primary use-case is for gaining perspective on the the live data size.\n\n\nUnit:\n bytes\n\n\nDimensions:\n n/a\n\n\njvm.gc.pause\n\n\nTimer reporting the pause time for a GC event. All of the values reported are stop the world pauses.\n\n\nUnit:\n\n\n\n\nstatistic=max\n: seconds\n\n\nstatistic=count\n: events/second\n\n\nstatistic=totalTime\n: seconds/second \n\n\n\n\nDimensions:\n\n\n\n\naction\n: action performed by the garbage collector (\njavadoc\n). There is no guarantee, but the typical values seen are \nend_of_major_GC\n and \nend_of_minor_GC\n. \n\n\ncause\n: cause that instigated GC (\njavadoc\n). For an explanation of common causes see the [[GC Causes]] page.\n\n\n\n\nAlerting\n\n\nThis section assumes the data is available in \nAtlas\n, but users of other systems should be able to take the idea and make it work. For all of these alerts it is recommended to check them on instance. At Netflix that can be done by selecting the option in alert ui:\n\n\n\n\n\n\n\n\nMax Pause Time\n\n\nExample to trigger an alert if the \npause time\n exceeds 500 milliseconds:\n\n\nname,jvm.gc.pause,:eq,\nstatistic,max,:eq,\n:and,\n:max,(,cause,),:by,\n0.5,:gt,\n$cause,:legend\n\n\n\n\nHeap Pressure\n\n\nExample to trigger an alert if the \nlive data size\n is over 70% of the heap:\n\n\nname,jvm.gc.liveDataSize,:eq,:max,\nname,jvm.gc.maxDataSize,:eq,:max,\n:div,100,:mul,\n70,:gt,\npercentUsed,:legend", 
            "title": "Garbage Collection"
        }, 
        {
            "location": "/ext/jvm-gc/#garbage-collection", 
            "text": "The GC module registers with the notification emitter of the  GarbageCollectorMXBean  to provide some basic GC logging and metrics.   Getting started  Logging  Metrics  Alerting", 
            "title": "Garbage Collection"
        }, 
        {
            "location": "/ext/jvm-gc/#getting-started", 
            "text": "For using it internally at Netflix see the [[Netflix integration]] guide, otherwise keep reading this section.", 
            "title": "Getting Started"
        }, 
        {
            "location": "/ext/jvm-gc/#requirements", 
            "text": "This library relies on the notification emitter added in 7u4, but there are known issues prior to 7u40. For G1 it is recommended to be on the latest version available.", 
            "title": "Requirements"
        }, 
        {
            "location": "/ext/jvm-gc/#dependencies", 
            "text": "com.netflix.spectator:spectator-ext-gc:0.35.0", 
            "title": "Dependencies"
        }, 
        {
            "location": "/ext/jvm-gc/#start-reporting", 
            "text": "Then in the initialization for the application:  import com.netflix.spectator.gc.GcLogger;\n...\n// Keep a single instance of the logger\nGcLogger gc = new GcLogger();\ngc.start(null);", 
            "title": "Start Reporting"
        }, 
        {
            "location": "/ext/jvm-gc/#logging", 
            "text": "After GC events an INFO level log message will get reported using slf4j. This makes it easy to GC events in the context of other log messages for the application. The logger name is  com.netflix.spectator.gc.GcLogger  and the message will look like:  ${GC_TYPE}: ${COLLECTOR_NAME}, id=${N}, at=${START_TIME}, duration=${T}ms, cause=[${CAUSE}], ${TOTAL_USAGE_BEFORE} =  ${TOTAL_USAGE_AFTER} / ${MAX_SIZE} (${PERCENT_USAGE_BEFORE} =  ${PERCENT_USAGE_AFTER})  The id can be used to verify events were not skipped or correlate with other sources like detailed GC logs. See [[GC causes]] for more details on the possible causes.  Sample:  2014-08-31 02:02:24,724  INFO [com.netflix.spectator.gc.GcLogger] YOUNG: ParNew, id=5281, at=Sun Aug 31 02:02:24 UTC 2014, duration=2ms, cause=[Allocation Failure], 0.4G =  0.3G / 1.8G (24.3% =  16.6%)", 
            "title": "Logging"
        }, 
        {
            "location": "/ext/jvm-gc/#metrics", 
            "text": "", 
            "title": "Metrics"
        }, 
        {
            "location": "/ext/jvm-gc/#jvmgcallocationrate", 
            "text": "The allocation rate measures how fast the application is allocating memory. It is a counter that is incremented after a GC event by the amount  youngGen.sizeBeforeGC . Technically, right now it is:  youngGen.sizeBeforeGC - youngGen.sizeAfterGC  However,  youngGen.sizeAfterGC  should be 0 and thus the size of young gen before the GC is the amount allocated since the previous GC event.  Unit:  bytes/second  Dimensions:  n/a", 
            "title": "jvm.gc.allocationRate"
        }, 
        {
            "location": "/ext/jvm-gc/#jvmgcpromotionrate", 
            "text": "The promotion rate measures how fast data is being moved from young generation into the old generation. It is a counter that is incremented after a GC event by the amount:  abs(oldGen.sizeAfterGC - oldGen.sizeBeforeGC)  Unit:  bytes/second  Dimensions:  n/a", 
            "title": "jvm.gc.promotionRate"
        }, 
        {
            "location": "/ext/jvm-gc/#jvmgclivedatasize", 
            "text": "The live data size is the size of the old generation after a major GC. The image below shows how the live data size view compares to a metric showing the current size of the memory pool:   Unit:  bytes  Dimensions:  n/a", 
            "title": "jvm.gc.liveDataSize"
        }, 
        {
            "location": "/ext/jvm-gc/#jvmgcmaxdatasize", 
            "text": "Maximum size for the old generation. Primary use-case is for gaining perspective on the the live data size.  Unit:  bytes  Dimensions:  n/a", 
            "title": "jvm.gc.maxDataSize"
        }, 
        {
            "location": "/ext/jvm-gc/#jvmgcpause", 
            "text": "Timer reporting the pause time for a GC event. All of the values reported are stop the world pauses.  Unit:   statistic=max : seconds  statistic=count : events/second  statistic=totalTime : seconds/second    Dimensions:   action : action performed by the garbage collector ( javadoc ). There is no guarantee, but the typical values seen are  end_of_major_GC  and  end_of_minor_GC .   cause : cause that instigated GC ( javadoc ). For an explanation of common causes see the [[GC Causes]] page.", 
            "title": "jvm.gc.pause"
        }, 
        {
            "location": "/ext/jvm-gc/#alerting", 
            "text": "This section assumes the data is available in  Atlas , but users of other systems should be able to take the idea and make it work. For all of these alerts it is recommended to check them on instance. At Netflix that can be done by selecting the option in alert ui:", 
            "title": "Alerting"
        }, 
        {
            "location": "/ext/jvm-gc/#max-pause-time", 
            "text": "Example to trigger an alert if the  pause time  exceeds 500 milliseconds:  name,jvm.gc.pause,:eq,\nstatistic,max,:eq,\n:and,\n:max,(,cause,),:by,\n0.5,:gt,\n$cause,:legend", 
            "title": "Max Pause Time"
        }, 
        {
            "location": "/ext/jvm-gc/#heap-pressure", 
            "text": "Example to trigger an alert if the  live data size  is over 70% of the heap:  name,jvm.gc.liveDataSize,:eq,:max,\nname,jvm.gc.maxDataSize,:eq,:max,\n:div,100,:mul,\n70,:gt,\npercentUsed,:legend", 
            "title": "Heap Pressure"
        }, 
        {
            "location": "/ext/jvm-gc-causes/", 
            "text": "GC Causes\n\n\nThe various GC causes aren't well documented. The list provided here comes from the \ngcCause.cpp\n file in the jdk and we include some information on what these mean for the application.\n\n\nSystem.gc__\n\n\nSomething called \nSystem.gc()\n. If you are seeing this once an hour it is likely related to the RMI GC interval. For more details see:\n\n\n\n\nUnexplained System.gc() calls due to Remote Method Invocation (RMI) or explict garbage collections\n\n\nsun.rmi.dgc.client.gcInterval\n\n\n\n\nFullGCAlot\n\n\nMost likely you'll never see this value. In debug builds of the jdk there is an option, \n-XX:+FullGCALot\n, that will trigger a full GC at a regular interval for testing purposes.\n\n\nScavengeAlot\n\n\nMost likely you'll never see this value. In debug builds of the jdk there is an option, \n-XX:+ScavengeALot\n, that will trigger a minor GC at a regular interval for testing purposes.\n\n\nAllocation_Profiler\n\n\nPrior to java 8 you would see this if running with the \n-Xaprof\n setting. It would be triggered just before the jvm exits. The \n-Xaprof\n option was removed in java 8.\n\n\nJvmtiEnv_ForceGarbageCollection\n\n\nSomething called the JVM tool interface function \nForceGarbageCollection\n. Look at the \n-agentlib\n param to java to see what agents are configured.\n\n\nGCLocker_Initiated_GC\n\n\nThe GC locker prevents GC from occurring when JNI code is in a \ncritical region\n. If GC is needed while a thread is in a critical region, then it will allow them to complete, i.e. call the corresponding release function. Other threads will not be permitted to enter a critical region. Once all threads are out of critical regions a GC event will be triggered. \n\n\nHeap_Inspection_Initiated_GC\n\n\nGC was initiated by an inspection operation on the heap. For example you can trigger this with \njmap\n:\n\n\n$ jmap -histo:live \npid\n\n\nHeap_Dump_Initiated_GC\n\n\nGC was initiated before dumping the heap. For example you can trigger this with \njmap\n:\n\n\n$ jmap -dump:live,format=b,file=heap.out \npid\n\n\nAnother common example would be clicking the Heap Dump button on the Monitor tab in \njvisualvm\n.\n\n\nWhiteBox_Initiated_Young_GC\n\n\nMost likely you'll never see this value. Used for testing hotspot, it indicates something called \nsun.hotspot.WhiteBox.youngGC()\n. \n\n\nNo_GC\n\n\nUsed for CMS. Unfortunately when using the mbeans this is the cause that typically gets reported for a major GC.\n\n\nAllocation_Failure\n\n\nUsually this means that there is an allocation request that is bigger than the available space in young generation and will typically be associated with a minor GC. For G1 this will likely be a major GC and it is more common to see \nG1_Evacuation_Pause\n for routine minor collections.\n\n\nOn linux the jvm will trigger a GC if the kernel indicates there isn't much memory left via \nmem_notify\n.\n\n\nTenured_Generation_Full\n\n\nNot used?\n\n\nPermanent_Generation_Full\n\n\nTriggered as a result of an allocation failure in \nPermGen\n. Pre java 8.\n\n\nMetadata_GC_Threshold\n\n\nTriggered as a result of an allocation failure in \nMetaspace\n. Metaspace replaced PermGen was added in java 8.\n\n\nCMS_Generation_Full\n\n\nNot used?\n\n\nCMS_Initial_Mark\n\n\nInitial mark phase of CMS, for more details see \nPhases of CMS\n. Unfortunately it doesn't appear to be reported via the mbeans and we just get \nNo_GC\n.\n\n\nCMS_Final_Remark\n\n\nRemark phase of CMS, for more details see \nPhases of CMS\n. Unfortunately it doesn't appear to be reported via the mbeans and we just get \nNo_GC\n.\n\n\nCMS_Concurrent_Mark\n\n\nConcurrent mark phase of CMS, for more details see \nPhases of CMS\n. Unfortunately it doesn't appear to be reported via the mbeans and we just get \nNo_GC\n.\n\n\nOld_Generation_Expanded_On_Last_Scavenge\n\n\nNot used?\n\n\nOld_Generation_Too_Full_To_Scavenge\n\n\nNot used?\n\n\nErgonomics\n\n\nThis indicates you are using the adaptive size policy, \n-XX:+UseAdaptiveSizePolicy\n and is on by default for recent versions, with the parallel collector (\n-XX:+UseParallelGC\n). For more details see \nThe Why of GC Ergonomics\n.\n\n\nG1_Evacuation_Pause\n\n\nAn evacuation pause is the most common young gen cause for G1 and indicates that it is copying live objects from one set of regions, young and sometimes young + old, to another set of regions. For more details see \nUnderstanding G1 GC Logs\n.\n\n\nG1_Humongous_Allocation\n\n\nA humongous allocation is one where the size is greater than 50% of the G1 region size. Before a humongous allocation the jvm checks if it should do a routine \nevacuation pause\n without regard to the actual allocation size, but if triggered due to this check the cause will be listed as humongous allocation. This cause is also used for any collections used to free up enough space for the allocation. \n\n\nLast_ditch_collection\n\n\nFor perm gen (java 7 or earlier) and metaspace (java 8+) a last ditch collection will be triggered if an allocation fails and the memory pool cannot be expanded.\n\n\nILLEGAL_VALUE_-\nlast_gc_cause\n-_ILLEGAL_VALUE\n\n\nIncluded for completeness, but you should never see this value.\n\n\nunknown_GCCause\n\n\nIncluded for completeness, but you should never see this value.", 
            "title": "GC Causes"
        }, 
        {
            "location": "/ext/jvm-gc-causes/#gc-causes", 
            "text": "The various GC causes aren't well documented. The list provided here comes from the  gcCause.cpp  file in the jdk and we include some information on what these mean for the application.", 
            "title": "GC Causes"
        }, 
        {
            "location": "/ext/jvm-gc-causes/#systemgc__", 
            "text": "Something called  System.gc() . If you are seeing this once an hour it is likely related to the RMI GC interval. For more details see:   Unexplained System.gc() calls due to Remote Method Invocation (RMI) or explict garbage collections  sun.rmi.dgc.client.gcInterval", 
            "title": "System.gc__"
        }, 
        {
            "location": "/ext/jvm-gc-causes/#fullgcalot", 
            "text": "Most likely you'll never see this value. In debug builds of the jdk there is an option,  -XX:+FullGCALot , that will trigger a full GC at a regular interval for testing purposes.", 
            "title": "FullGCAlot"
        }, 
        {
            "location": "/ext/jvm-gc-causes/#scavengealot", 
            "text": "Most likely you'll never see this value. In debug builds of the jdk there is an option,  -XX:+ScavengeALot , that will trigger a minor GC at a regular interval for testing purposes.", 
            "title": "ScavengeAlot"
        }, 
        {
            "location": "/ext/jvm-gc-causes/#allocation_profiler", 
            "text": "Prior to java 8 you would see this if running with the  -Xaprof  setting. It would be triggered just before the jvm exits. The  -Xaprof  option was removed in java 8.", 
            "title": "Allocation_Profiler"
        }, 
        {
            "location": "/ext/jvm-gc-causes/#jvmtienv_forcegarbagecollection", 
            "text": "Something called the JVM tool interface function  ForceGarbageCollection . Look at the  -agentlib  param to java to see what agents are configured.", 
            "title": "JvmtiEnv_ForceGarbageCollection"
        }, 
        {
            "location": "/ext/jvm-gc-causes/#gclocker_initiated_gc", 
            "text": "The GC locker prevents GC from occurring when JNI code is in a  critical region . If GC is needed while a thread is in a critical region, then it will allow them to complete, i.e. call the corresponding release function. Other threads will not be permitted to enter a critical region. Once all threads are out of critical regions a GC event will be triggered.", 
            "title": "GCLocker_Initiated_GC"
        }, 
        {
            "location": "/ext/jvm-gc-causes/#heap_inspection_initiated_gc", 
            "text": "GC was initiated by an inspection operation on the heap. For example you can trigger this with  jmap :  $ jmap -histo:live  pid", 
            "title": "Heap_Inspection_Initiated_GC"
        }, 
        {
            "location": "/ext/jvm-gc-causes/#heap_dump_initiated_gc", 
            "text": "GC was initiated before dumping the heap. For example you can trigger this with  jmap :  $ jmap -dump:live,format=b,file=heap.out  pid  Another common example would be clicking the Heap Dump button on the Monitor tab in  jvisualvm .", 
            "title": "Heap_Dump_Initiated_GC"
        }, 
        {
            "location": "/ext/jvm-gc-causes/#whitebox_initiated_young_gc", 
            "text": "Most likely you'll never see this value. Used for testing hotspot, it indicates something called  sun.hotspot.WhiteBox.youngGC() .", 
            "title": "WhiteBox_Initiated_Young_GC"
        }, 
        {
            "location": "/ext/jvm-gc-causes/#no_gc", 
            "text": "Used for CMS. Unfortunately when using the mbeans this is the cause that typically gets reported for a major GC.", 
            "title": "No_GC"
        }, 
        {
            "location": "/ext/jvm-gc-causes/#allocation_failure", 
            "text": "Usually this means that there is an allocation request that is bigger than the available space in young generation and will typically be associated with a minor GC. For G1 this will likely be a major GC and it is more common to see  G1_Evacuation_Pause  for routine minor collections.  On linux the jvm will trigger a GC if the kernel indicates there isn't much memory left via  mem_notify .", 
            "title": "Allocation_Failure"
        }, 
        {
            "location": "/ext/jvm-gc-causes/#tenured_generation_full", 
            "text": "Not used?", 
            "title": "Tenured_Generation_Full"
        }, 
        {
            "location": "/ext/jvm-gc-causes/#permanent_generation_full", 
            "text": "Triggered as a result of an allocation failure in  PermGen . Pre java 8.", 
            "title": "Permanent_Generation_Full"
        }, 
        {
            "location": "/ext/jvm-gc-causes/#metadata_gc_threshold", 
            "text": "Triggered as a result of an allocation failure in  Metaspace . Metaspace replaced PermGen was added in java 8.", 
            "title": "Metadata_GC_Threshold"
        }, 
        {
            "location": "/ext/jvm-gc-causes/#cms_generation_full", 
            "text": "Not used?", 
            "title": "CMS_Generation_Full"
        }, 
        {
            "location": "/ext/jvm-gc-causes/#cms_initial_mark", 
            "text": "Initial mark phase of CMS, for more details see  Phases of CMS . Unfortunately it doesn't appear to be reported via the mbeans and we just get  No_GC .", 
            "title": "CMS_Initial_Mark"
        }, 
        {
            "location": "/ext/jvm-gc-causes/#cms_final_remark", 
            "text": "Remark phase of CMS, for more details see  Phases of CMS . Unfortunately it doesn't appear to be reported via the mbeans and we just get  No_GC .", 
            "title": "CMS_Final_Remark"
        }, 
        {
            "location": "/ext/jvm-gc-causes/#cms_concurrent_mark", 
            "text": "Concurrent mark phase of CMS, for more details see  Phases of CMS . Unfortunately it doesn't appear to be reported via the mbeans and we just get  No_GC .", 
            "title": "CMS_Concurrent_Mark"
        }, 
        {
            "location": "/ext/jvm-gc-causes/#old_generation_expanded_on_last_scavenge", 
            "text": "Not used?", 
            "title": "Old_Generation_Expanded_On_Last_Scavenge"
        }, 
        {
            "location": "/ext/jvm-gc-causes/#old_generation_too_full_to_scavenge", 
            "text": "Not used?", 
            "title": "Old_Generation_Too_Full_To_Scavenge"
        }, 
        {
            "location": "/ext/jvm-gc-causes/#ergonomics", 
            "text": "This indicates you are using the adaptive size policy,  -XX:+UseAdaptiveSizePolicy  and is on by default for recent versions, with the parallel collector ( -XX:+UseParallelGC ). For more details see  The Why of GC Ergonomics .", 
            "title": "Ergonomics"
        }, 
        {
            "location": "/ext/jvm-gc-causes/#g1_evacuation_pause", 
            "text": "An evacuation pause is the most common young gen cause for G1 and indicates that it is copying live objects from one set of regions, young and sometimes young + old, to another set of regions. For more details see  Understanding G1 GC Logs .", 
            "title": "G1_Evacuation_Pause"
        }, 
        {
            "location": "/ext/jvm-gc-causes/#g1_humongous_allocation", 
            "text": "A humongous allocation is one where the size is greater than 50% of the G1 region size. Before a humongous allocation the jvm checks if it should do a routine  evacuation pause  without regard to the actual allocation size, but if triggered due to this check the cause will be listed as humongous allocation. This cause is also used for any collections used to free up enough space for the allocation.", 
            "title": "G1_Humongous_Allocation"
        }, 
        {
            "location": "/ext/jvm-gc-causes/#last_ditch_collection", 
            "text": "For perm gen (java 7 or earlier) and metaspace (java 8+) a last ditch collection will be triggered if an allocation fails and the memory pool cannot be expanded.", 
            "title": "Last_ditch_collection"
        }, 
        {
            "location": "/ext/jvm-gc-causes/#illegal_value_-last_gc_cause-_illegal_value", 
            "text": "Included for completeness, but you should never see this value.", 
            "title": "ILLEGAL_VALUE_-last_gc_cause-_ILLEGAL_VALUE"
        }, 
        {
            "location": "/ext/jvm-gc-causes/#unknown_gccause", 
            "text": "Included for completeness, but you should never see this value.", 
            "title": "unknown_GCCause"
        }, 
        {
            "location": "/ext/jvm-memory-pools/", 
            "text": "Memory Pools\n\n\nUses the \nMemoryPoolMXBean\n provided by the JDK to monitor the sizes of java memory spaces such as perm gen, eden, old gen, etc. \n\n\nGetting Started\n\n\nTo get information about memory pools in spectator just setup registration of standard MXBeans. Note, if you are building an app at Netflix this should happen automatically via the normal platform initialization.\n\n\nimport com.netflix.spectator.api.Spectator;\nimport com.netflix.spectator.jvm.Jmx;\n\nJmx.registerStandardMXBeans(Spectator.registry());\n\n\n\n\nMetrics\n\n\njvm.memory.used\n\n\nGauge reporting the current amount of memory used. For the young and old gen pools this metric will typically have a sawtooth pattern. For alerting or detecting memory pressure the \nlive data size\n is probably a better option.\n\n\nUnit:\n bytes\n\n\nDimensions:\n\nsee \nmetric dimensions\n\n\njvm.memory.committed\n\n\nGauge reporting the current amount of memory committed. From the \njavadocs\n, committed is:\n\n\n\n\nThe amount of memory (in bytes) that is guaranteed to be available for use by the Java virtual machine. The amount of committed memory may change over time (increase or decrease). The Java virtual machine may release memory to the system and committed could be less than init. committed will always be greater than or equal to used.\n\n\n\n\nUnit:\n bytes \n\n\nDimensions:\n\nsee \nmetric dimensions\n\n\njvm.memory.max\n\n\nGauge reporting the max amount of memory that can be used. From the \njavadocs\n, committed is:\n\n\n\n\nThe maximum amount of memory (in bytes) that can be used for memory management. Its value may be undefined. The maximum amount of memory may change over time if defined. The amount of used and committed memory will always be less than or equal to max if max is defined. A memory allocation may fail if it attempts to increase the used memory such that used \n committed even if used \n= max would still be true (for example, when the system is low on virtual memory).\n\n\n\n\nUnit:\n bytes \n\n\nDimensions:\n\nsee \nmetric dimensions\n\n\nMetric Dimensions\n\n\nAll memory metrics have the following dimensions:\n\n\n\n\nid\n: name of the memory pool being reported. The names of the pools vary depending on the garbage collector algorithm being used.\n\n\nmemtype\n: type of memory. It has two possible values: \nHEAP\n and \nNON_HEAP\n. For more information see the javadocs for \nMemoryType\n.", 
            "title": "Memory Pools"
        }, 
        {
            "location": "/ext/jvm-memory-pools/#memory-pools", 
            "text": "Uses the  MemoryPoolMXBean  provided by the JDK to monitor the sizes of java memory spaces such as perm gen, eden, old gen, etc.", 
            "title": "Memory Pools"
        }, 
        {
            "location": "/ext/jvm-memory-pools/#getting-started", 
            "text": "To get information about memory pools in spectator just setup registration of standard MXBeans. Note, if you are building an app at Netflix this should happen automatically via the normal platform initialization.  import com.netflix.spectator.api.Spectator;\nimport com.netflix.spectator.jvm.Jmx;\n\nJmx.registerStandardMXBeans(Spectator.registry());", 
            "title": "Getting Started"
        }, 
        {
            "location": "/ext/jvm-memory-pools/#metrics", 
            "text": "", 
            "title": "Metrics"
        }, 
        {
            "location": "/ext/jvm-memory-pools/#jvmmemoryused", 
            "text": "Gauge reporting the current amount of memory used. For the young and old gen pools this metric will typically have a sawtooth pattern. For alerting or detecting memory pressure the  live data size  is probably a better option.  Unit:  bytes  Dimensions: \nsee  metric dimensions", 
            "title": "jvm.memory.used"
        }, 
        {
            "location": "/ext/jvm-memory-pools/#jvmmemorycommitted", 
            "text": "Gauge reporting the current amount of memory committed. From the  javadocs , committed is:   The amount of memory (in bytes) that is guaranteed to be available for use by the Java virtual machine. The amount of committed memory may change over time (increase or decrease). The Java virtual machine may release memory to the system and committed could be less than init. committed will always be greater than or equal to used.   Unit:  bytes   Dimensions: \nsee  metric dimensions", 
            "title": "jvm.memory.committed"
        }, 
        {
            "location": "/ext/jvm-memory-pools/#jvmmemorymax", 
            "text": "Gauge reporting the max amount of memory that can be used. From the  javadocs , committed is:   The maximum amount of memory (in bytes) that can be used for memory management. Its value may be undefined. The maximum amount of memory may change over time if defined. The amount of used and committed memory will always be less than or equal to max if max is defined. A memory allocation may fail if it attempts to increase the used memory such that used   committed even if used  = max would still be true (for example, when the system is low on virtual memory).   Unit:  bytes   Dimensions: \nsee  metric dimensions", 
            "title": "jvm.memory.max"
        }, 
        {
            "location": "/ext/jvm-memory-pools/#metric-dimensions", 
            "text": "All memory metrics have the following dimensions:   id : name of the memory pool being reported. The names of the pools vary depending on the garbage collector algorithm being used.  memtype : type of memory. It has two possible values:  HEAP  and  NON_HEAP . For more information see the javadocs for  MemoryType .", 
            "title": "Metric Dimensions"
        }, 
        {
            "location": "/ext/log4j2/", 
            "text": "Log4j2 Appender\n\n\nCustom appender for \nlog4j2\n to track the number of log messages reported. \n\n\nGetting Started\n\n\nTo use it simply add a dependency:\n\n\ncom.netflix.spectator:spectator-ext-log4j2:0.35.0\n\n\n\n\nThen in your application initialization:\n\n\nRegistry registry = ...\nSpectatorAppender.addToRootLogger(\n    registry,             // Registry to use\n    \nspectator\n,          // Name for the appender\n    false);               // Should stack traces be ignored?\n\n\n\n\nThis will add the appender to the root logger and register a listener so it will get re-added if the configuration changes. You can also use the appender by specifying it in the log4j2 configuration, but this will cause some of the loggers in Spectator to get created before log4j is properly initialized and result in some lost log messages. With that caveat in mind, if you need the additional flexibility of using the configuration then specify the \nSpectator\n appender:\n\n\n?xml version=\n1.0\n encoding=\nUTF-8\n?\n\n\nConfiguration monitorInterval=\n5\n status=\nwarn\n\n  \nAppenders\n\n    \nSpectator name=\nroot\n/\n\n  \n/Appenders\n\n  \nLoggers\n\n    \nRoot level=\ndebug\n\n      \nAppenderRef ref=\nroot\n/\n\n    \n/Root\n\n  \n/Loggers\n\n\n/Configuration\n\n\n\n\n\nMetrics\n\n\nlog4j.numMessages\n\n\nCounters showing the number of messages that have been passed to the appender.\n\n\nUnit:\n messages/second\n\n\nDimensions:\n\n\n\n\nappender\n: name of the spectator appender.\n\n\nloglevel\n: standard log level of the events.\n\n\n\n\nlog4j.numStackTraces\n\n\nCounter for the number of messages with stack traces written to the logs. This will only be collected if the \nignoreExceptions\n flag is set to false for the appender.\n\n\nUnit:\n messages/second\n\n\nDimensions:\n\n\n\n\nappender\n: name of the spectator appender.\n\n\nloglevel\n: standard log level of the events.\n\n\nexception\n: simple class name for the exception that was thrown.\n\n\nfile\n: file name for where the exception was thrown.", 
            "title": "Log4j2 Appender"
        }, 
        {
            "location": "/ext/log4j2/#log4j2-appender", 
            "text": "Custom appender for  log4j2  to track the number of log messages reported.", 
            "title": "Log4j2 Appender"
        }, 
        {
            "location": "/ext/log4j2/#getting-started", 
            "text": "To use it simply add a dependency:  com.netflix.spectator:spectator-ext-log4j2:0.35.0  Then in your application initialization:  Registry registry = ...\nSpectatorAppender.addToRootLogger(\n    registry,             // Registry to use\n     spectator ,          // Name for the appender\n    false);               // Should stack traces be ignored?  This will add the appender to the root logger and register a listener so it will get re-added if the configuration changes. You can also use the appender by specifying it in the log4j2 configuration, but this will cause some of the loggers in Spectator to get created before log4j is properly initialized and result in some lost log messages. With that caveat in mind, if you need the additional flexibility of using the configuration then specify the  Spectator  appender:  ?xml version= 1.0  encoding= UTF-8 ?  Configuration monitorInterval= 5  status= warn \n   Appenders \n     Spectator name= root / \n   /Appenders \n   Loggers \n     Root level= debug \n       AppenderRef ref= root / \n     /Root \n   /Loggers  /Configuration", 
            "title": "Getting Started"
        }, 
        {
            "location": "/ext/log4j2/#metrics", 
            "text": "", 
            "title": "Metrics"
        }, 
        {
            "location": "/ext/log4j2/#log4jnummessages", 
            "text": "Counters showing the number of messages that have been passed to the appender.  Unit:  messages/second  Dimensions:   appender : name of the spectator appender.  loglevel : standard log level of the events.", 
            "title": "log4j.numMessages"
        }, 
        {
            "location": "/ext/log4j2/#log4jnumstacktraces", 
            "text": "Counter for the number of messages with stack traces written to the logs. This will only be collected if the  ignoreExceptions  flag is set to false for the appender.  Unit:  messages/second  Dimensions:   appender : name of the spectator appender.  loglevel : standard log level of the events.  exception : simple class name for the exception that was thrown.  file : file name for where the exception was thrown.", 
            "title": "log4j.numStackTraces"
        }, 
        {
            "location": "/registry/metrics3/", 
            "text": "Metrics3 Registry\n\n\nRegistry that uses \nmetrics3\n as the\nunderlying implementation. To use the metrics registry, add a dependency on the\n\nspectator-reg-metrics3\n library. For gradle:\n\n\ncom.netflix.spectator:spectator-reg-metrics3:0.35.0\n\n\n\n\nThen when initializing the application, use the \nMetricsRegistry\n. For more\ninformation see the \nmetrics3 example\n.", 
            "title": "Metrics3"
        }, 
        {
            "location": "/registry/metrics3/#metrics3-registry", 
            "text": "Registry that uses  metrics3  as the\nunderlying implementation. To use the metrics registry, add a dependency on the spectator-reg-metrics3  library. For gradle:  com.netflix.spectator:spectator-reg-metrics3:0.35.0  Then when initializing the application, use the  MetricsRegistry . For more\ninformation see the  metrics3 example .", 
            "title": "Metrics3 Registry"
        }, 
        {
            "location": "/registry/servo/", 
            "text": "Servo Registry\n\n\nRegistry that uses \nservo\n as the underlying\nimplementation. To use the servo registry, add a dependency on the\n\nspectator-reg-servo\n library. For gradle:\n\n\ncom.netflix.spectator:spectator-reg-servo:0.35.0\n\n\n\n\nThen when initializing the application, use the \nServoRegistry\n. If using guice\nthen that would look like:\n\n\nInjector injector = Guice.createInjector(new AbstractModule() {\n    @Override protected void configure() {\n    }\n\n    @Provides\n    @Singleton\n    private Registry providesRegistry() {\n      return new ServoRegistry();\n    }\n  });\n\n\n\n\nFor more information see the \nservo example\n.\nNote if running internally at Netflix see the [[Netflix Integration]] docs\ninstead.", 
            "title": "Servo"
        }, 
        {
            "location": "/registry/servo/#servo-registry", 
            "text": "Registry that uses  servo  as the underlying\nimplementation. To use the servo registry, add a dependency on the spectator-reg-servo  library. For gradle:  com.netflix.spectator:spectator-reg-servo:0.35.0  Then when initializing the application, use the  ServoRegistry . If using guice\nthen that would look like:  Injector injector = Guice.createInjector(new AbstractModule() {\n    @Override protected void configure() {\n    }\n\n    @Provides\n    @Singleton\n    private Registry providesRegistry() {\n      return new ServoRegistry();\n    }\n  });  For more information see the  servo example .\nNote if running internally at Netflix see the [[Netflix Integration]] docs\ninstead.", 
            "title": "Servo Registry"
        }, 
        {
            "location": "/registry/tdigest/", 
            "text": "T-Digest Registry\n\n\n\n\nWarning\n\n\nDeprecated, use PercentileTimer or PercentileDistributionSummary instead.\n\n\n\n\nThe TDigest registry is used for collecting dimensional percentile data and reporting to backends. This is currently an experiment and not ready for general use. Current instructions assume it is being used \ninternally at Netflix\n.\n\n\nGetting Started\n\n\nTo use it simply add a dependency:\n\n\ncom.netflix.spectator:spectator-reg-tdigest:0.35.0\n\n\n\n\nAdd the \nTDigestModule\n to the set of modules used with guice:\n\n\nInjector injector = Guice.createInjector(\n  new SpectatorModule(),\n  new TDigestModule(),\n  ...);\n\n\n\n\nThen just inject the \nTDigestRegistry\n:\n\n\npublic class Foo {\n  private final Registry registry;\n\n  public Foo(TDigestRegistry digestRegistry) {\n    registry = digestRegistry;\n  }\n\n  public void doSomething() {\n    registry.timer(\nfoo.doSomething\n).record(() -\n {\n      ... something ...\n    });\n  }\n}\n\n\n\n\nTimers and distribution summaries accessed via the \nTDigestRegistry\n will be recorded to both the main registry and the digest registry.\n\n\nRecommendations\n\n\n\n\nUse digests sparingly. The digest structure will take more memory locally and have additional overhead compared to typical implementations. \n\n\n\n\nTesting\n\n\nFor unit tests use the \nTDigestTestModule\n to get an injectable \nTDigestRegistry\n. Then follow the \nnormal testing instructions\n. Example:\n\n\n@RunWith(JUnit4.class)\npublic class FooTest {\n\n  @Test\n  public void doSomething() throws Exception {\n    Injector injector = Guice.createInjector(TDigestTestModule.create());\n    injector.getInstance(Foo.class).doSomething();\n\n    final TDigestRegistry r = injector.getInstance(TDigestRegistry.class);\n    Assert.assertEquals(1, r.timer(\nfoo\n).count());\n    Assert.assertEquals(42, r.timer(\nfoo\n).totalTime());\n  }\n\n  private static class Foo {\n    private final Timer t;\n\n    @Inject\n    Foo(TDigestRegistry registry) {\n      t = registry.timer(\nfoo\n);\n    }\n\n    void doSomething() {\n      t.record(42, TimeUnit.NANOSECONDS);\n    }\n  }\n}\n\n\n\n\nKnown Issues\n\n\n\n\nOnly reports to kinesis for now. This will be changed after the configuration format is figured out.\n\n\nThere is still some debate about whether to control the access via the code and injecting the specific registry or using configuration. \n\n\nThere is work in progress on having a fixed limit to protect both the local client and backends. If the limit is reached rollup policies would get triggered to gracefully degrade.\n\n\nCan we support high level digest along with basic timer with more dimensionality. Still investigating pending the outcome of previous bullets.\n\n\nNot yet supported via sidecar endpoints.", 
            "title": "TDigest"
        }, 
        {
            "location": "/registry/tdigest/#t-digest-registry", 
            "text": "Warning  Deprecated, use PercentileTimer or PercentileDistributionSummary instead.   The TDigest registry is used for collecting dimensional percentile data and reporting to backends. This is currently an experiment and not ready for general use. Current instructions assume it is being used  internally at Netflix .", 
            "title": "T-Digest Registry"
        }, 
        {
            "location": "/registry/tdigest/#getting-started", 
            "text": "To use it simply add a dependency:  com.netflix.spectator:spectator-reg-tdigest:0.35.0  Add the  TDigestModule  to the set of modules used with guice:  Injector injector = Guice.createInjector(\n  new SpectatorModule(),\n  new TDigestModule(),\n  ...);  Then just inject the  TDigestRegistry :  public class Foo {\n  private final Registry registry;\n\n  public Foo(TDigestRegistry digestRegistry) {\n    registry = digestRegistry;\n  }\n\n  public void doSomething() {\n    registry.timer( foo.doSomething ).record(() -  {\n      ... something ...\n    });\n  }\n}  Timers and distribution summaries accessed via the  TDigestRegistry  will be recorded to both the main registry and the digest registry.", 
            "title": "Getting Started"
        }, 
        {
            "location": "/registry/tdigest/#recommendations", 
            "text": "Use digests sparingly. The digest structure will take more memory locally and have additional overhead compared to typical implementations.", 
            "title": "Recommendations"
        }, 
        {
            "location": "/registry/tdigest/#testing", 
            "text": "For unit tests use the  TDigestTestModule  to get an injectable  TDigestRegistry . Then follow the  normal testing instructions . Example:  @RunWith(JUnit4.class)\npublic class FooTest {\n\n  @Test\n  public void doSomething() throws Exception {\n    Injector injector = Guice.createInjector(TDigestTestModule.create());\n    injector.getInstance(Foo.class).doSomething();\n\n    final TDigestRegistry r = injector.getInstance(TDigestRegistry.class);\n    Assert.assertEquals(1, r.timer( foo ).count());\n    Assert.assertEquals(42, r.timer( foo ).totalTime());\n  }\n\n  private static class Foo {\n    private final Timer t;\n\n    @Inject\n    Foo(TDigestRegistry registry) {\n      t = registry.timer( foo );\n    }\n\n    void doSomething() {\n      t.record(42, TimeUnit.NANOSECONDS);\n    }\n  }\n}", 
            "title": "Testing"
        }, 
        {
            "location": "/registry/tdigest/#known-issues", 
            "text": "Only reports to kinesis for now. This will be changed after the configuration format is figured out.  There is still some debate about whether to control the access via the code and injecting the specific registry or using configuration.   There is work in progress on having a fixed limit to protect both the local client and backends. If the limit is reached rollup policies would get triggered to gracefully degrade.  Can we support high level digest along with basic timer with more dimensionality. Still investigating pending the outcome of previous bullets.  Not yet supported via sidecar endpoints.", 
            "title": "Known Issues"
        }
    ]
}